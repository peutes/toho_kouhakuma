<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>東方AI紅白魔 ~ Dual Boss Shooter ~</title>

    <meta name="description" content="AIが生成した東方Projectの二次創作弾幕シューティングゲーム(同人ゲーム、二次創作ゲーム、Webゲーム)。自機は河城にとり！立ちはだかる博麗霊夢と霧雨魔理沙を撃破しよう。PCでもスマホでも遊べます。">
    <meta name="keywords" content="東方, 東方Project, 弾幕, シューティング, STG, ゲーム, Webゲーム, ブラウザゲーム, 同人ゲーム, 二次創作ゲーム, 二次創作, 無料, AI, Gemini, 博麗霊夢, 霧雨魔理沙, 河城にとり">
    <meta name="author" content="Gemini">

    <meta property="og:type" content="website">
    <meta property="og:title" content="東方AI紅白魔 ~ Dual Boss Shooter ~">
    <meta property="og:description" content="AIが生成した東方Projectの二次創作弾幕シューティングゲーム(同人ゲーム、二次創作ゲーム、Webゲーム)。自機は河城にとり！立ちはだかる博麗霊夢と霧雨魔理沙を撃破しよう。PCでもスマホでも遊べます。">
    <meta property="og:image" content="https://peutes.github.io/toho_kouhakuma/img/title.png">
    <meta property="og:url" content="https://peutes.github.io/toho_kouhakuma/">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://peutes.github.io/toho_kouhakuma/">
    <meta property="twitter:title" content="東方AI紅白魔 ~ Dual Boss Shooter ~">
    <meta property="twitter:description" content="AIが生成した東方Projectの二次創作弾幕シューティングゲーム(同人ゲーム、二次創作ゲーム、Webゲーム)。自機は河城にとり！立ちはだかる博麗霊夢と霧雨魔理沙を撃破しよう。PCでもスマホでも遊べます。">
    <meta property="twitter:image" content="https://peutes.github.io/toho_kouhakuma/img/title.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "東方AI紅白魔 ~ Dual Boss Shooter ~",
      "description": "AIが生成した東方Projectの二次創作弾幕シューティングゲーム(同人ゲーム、二次創作ゲーム、Webゲーム)。自機は河城にとり！立ちはだかる博麗霊夢と霧雨魔理沙を撃破しよう。PCでもスマホでも遊べます。",
      "genre": ["Shooter", "Bullet Hell", "Danmaku", "Touhou Project", "Fan Game"],
      "playMode": "SinglePlayer",
      "applicationCategory": "Game",
      "operatingSystem": "Windows, MacOS, Linux, iOS, Android, Web browser",
      "author": {
        "@type": "Person",
        "name": "Gemini"
      }
    }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        html, body {
            background-color: #000;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #game-wrapper {
             /* Wrapper for scaling */
        }
        #game-container {
            display: flex;
            border: 2px solid #fff;
            box-shadow: 0 0 20px #ff00ff;
            width: 804px;
            height: 804px;
            transform-origin: center center;
        }
        #game-canvas-wrapper {
            position: relative;
            width: 600px;
            height: 800px;
            overflow: hidden;
        }
        #game-canvas {
            background-color: #010517;
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            animation: scroll-bg 30s linear infinite;
        }
        @keyframes scroll-bg {
            from { background-position-y: 0px; }
            to { background-position-y: 550px; }
        }
        #sidebar {
            width: 200px;
            background-color: #1c0c1c;
            padding: 20px;
            box-sizing: border-box;
            border-left: 2px solid #fff;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #sidebar h2 {
            margin-top: 0;
            color: #ff5a5a;
            text-shadow: 0 0 5px #ff5a5a;
        }
        #sidebar .info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            margin-bottom: 15px;
        }
        #sidebar .info-label {
            color: #aaa;
        }
        #sidebar .info-value {
            color: #fff;
        }
        #boss-info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 5px 10px;
            box-sizing: border-box;
            background: rgba(28, 12, 28, 0.7);
            z-index: 50;
            border-bottom: 1px dashed #fff;
        }
        #boss-name-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #boss-name-container h3 {
            font-size: 14px;
            margin: 0;
        }
        #boss-spell-lives {
            color: #ffc4e1;
            font-size: 14px;
        }
        #boss-health-bar-container {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #fff;
            border-radius: 3px;
            margin-top: 3px;
        }
        #boss-health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #9400d3, #ff00ff);
            border-radius: 2px;
            transition: width 0.2s ease-out;
        }
        #spell-card-name {
            margin-top: 3px;
            font-size: 12px;
            height: 16px;
            text-align: right;
            color: #ffc4e1;
        }
        #player-images, #boss-images, #enemy-images {
            display: none;
        }
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
        }
        #start-screen img {
            max-width: 85%;
            height: auto;
        }
        #start-screen p {
            font-size: 24px;
        }
        #start-screen .controls {
            margin-top: 20px;
            text-align: left;
        }
        #start-screen .controls p {
            font-size: 15px;
            margin: 4px 0;
        }
        #message-overlay, #dialogue-box {
            user-select: none;
        }
        #message-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            text-align: center;
            text-shadow: 0 0 20px #f0f;
            z-index: 90;
        }
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: calc(100% - 40px);
            height: 200px;
            border: 1px solid #66f;
            padding: 10px;
            padding-bottom: 25px;
            background: rgba(0,0,50,0.8);
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.4;
            cursor: pointer;
            z-index: 80;
            overflow-y: scroll;
        }
        #dialogue-box::-webkit-scrollbar { width: 8px; }
        #dialogue-box::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #dialogue-box::-webkit-scrollbar-thumb { background-color: #888; border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
        #dialogue-box::-webkit-scrollbar-thumb:hover { background-color: #aaa; }
        @keyframes blinker { 50% { opacity: 0.5; } }
        .continue-prompt {
            position: absolute;
            bottom: 5px;
            right: 10px;
            color: #ffff88;
            font-weight: bold;
            animation: blinker 1.5s linear infinite;
            text-shadow: 0 0 5px #000;
        }
        #boss-cutin {
            position: absolute;
            top: 150px;
            left: 100%;
            z-index: 60;
            opacity: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #boss-cutin.animate {
            animation: boss-cutin-anim 2.5s ease-in-out forwards;
        }
        #boss-cutin img {
            width: 400px;
            height: auto;
            border: 2px solid white;
            box-shadow: 0 0 20px red;
        }
        #spell-card-cutin-name {
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            margin-top: 10px;
        }
        @keyframes boss-cutin-anim {
            0% { left: 100%; opacity: 1; }
            20% { left: 50%; transform: translateX(-50%); opacity: 1; }
            80% { left: 50%; transform: translateX(-50%); opacity: 1; }
            100% { left: -100%; opacity: 0; }
        }

        /* --- ★ 修正: モバイルレイアウト関連のCSSを改善 --- */
        .mobile-layout #game-container {
            flex-direction: column;
            width: 100%; /* JSで画面サイズに設定 */
            height: 100%; /* JSで画面サイズに設定 */
            border: none;
            box-shadow: none;
        }
        .mobile-layout #game-canvas-wrapper {
            flex-grow: 1; /* ★ 修正: 高さを可変に */
            width: 100%;  /* ★ 修正: 幅を100%に */
            min-height: 0;
            display: flex; /* ★ 修正: canvasを中央揃えにするためflexを追加 */
            justify-content: center;
            align-items: center;
        }
        .mobile-layout #game-canvas {
            /* ★ 修正: JSでサイズを計算して適用するため、ここではリセット */
            max-width: 100%;
            max-height: 100%;
        }
        .mobile-layout #sidebar {
            width: 100%;
            height: auto; /* ★ 修正: 高さを自動に */
            flex-shrink: 0;
            border-left: none;
            border-top: 2px solid #fff;
            flex-direction: column;
            justify-content: center;
            padding: 5px; /* ★ 修正: パディングを調整 */
            box-sizing: border-box;
        }
        .mobile-layout #info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px 10px;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }
        .mobile-layout #sidebar h2 {
            grid-column: 1 / -1;
            font-size: clamp(14px, 4.5vw, 18px);
            margin: 5px 0;
            text-align: center;
        }
        .mobile-layout #sidebar .info {
            font-size: clamp(11px, 3.5vw, 14px); /* ★ 修正: 文字サイズを可変に */
            margin-bottom: 2px;
            flex-direction: column; /* ★ 修正: ラベルと値を縦に並べる */
            align-items: flex-start;
        }
        .mobile-layout #sidebar .info-label {
            color: #aaa;
            font-size: 0.8em; /* ラベルを少し小さく */
        }
        .mobile-layout #sidebar .info-value {
             align-self: flex-end; /* 値を右揃えに */
        }
        .mobile-layout #dialogue-box {
            height: 160px;
            bottom: 10px;
            left: 5%;
            width: 90%;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="game-canvas-wrapper">
                <div id="start-screen">
                    <img src="https://peutes.github.io/toho_kouhakuma/img/title.png" alt="東方AI紅白魔">
                    <p style="margin-top: 20px;">タップしてスタート</p> <div class="controls">
                        <div id="pc-controls" style="display: none;">
                            <p><b>操作説明(PC)</b></p>
                            <p>移動: 十字キー</p>
                            <p>ショット: Zキー</p>
                            <p>ボム: Xキー</p>
                            <p>低速移動: Shiftキー</p>
                        </div>
                        <div id="mobile-controls" style="display: none;">
                            <p><b>操作説明(SP)</b></p>
                            <p>移動: 指でドラッグ</p>
                            <p>ショット: オート</p>
                            <p>ボム: ダブルタップ</p>
                        </div>
                    </div>
                </div>
                <div id="message-overlay"></div>
                <div id="boss-info" style="display: none;">
                    <div id="boss-name-container">
                        <h3 id="boss-display-name">BOSS</h3>
                        <span id="boss-spell-lives"></span>
                    </div>
                    <div id="boss-health-bar-container">
                        <div id="boss-health-bar"></div>
                    </div>
                    <p id="spell-card-name"></p>
                </div>
                <div id="boss-cutin"><img id="boss-cutin-img" src="" alt="Boss Cut-in"><div id="spell-card-cutin-name"></div></div>
                <canvas id="game-canvas" width="600" height="800"></canvas>
                <div id="dialogue-box" style="display: none;"></div>
            </div>
            <div id="sidebar">
                <h2 id="sidebar-title">東方AI紅白魔</h2>
                <div id="info-grid">
                    <div class="info">
                        <span class="info-label">SCORE</span>
                        <span id="score" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">PLAYER</span>
                        <span id="lives" class="info-value"></span>
                    </div>
                     <div class="info">
                        <span class="info-label">POWER</span>
                        <span id="power" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">GRAZE</span>
                        <span id="graze" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">BOMB</span>
                        <span id="bombs" class="info-value"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="player-images">
        <img id="player-img" src="https://peutes.github.io/toho_kouhakuma/img/nitori.png" alt="にとり">
        <img id="option-img" src="https://peutes.github.io/toho_kouhakuma/img/bomb.png" alt="オプション">
    </div>
    <div id="boss-images">
        <img id="reimu-img" src="https://peutes.github.io/toho_kouhakuma/img/reimu.png" alt="霊夢">
        <img id="marisa-img" src="https://peutes.github.io/toho_kouhakuma/img/marisa.png" alt="魔理沙">
    </div>
    <div id="enemy-images">
        <img id="yousei-midori-img" src="https://peutes.github.io/toho_kouhakuma/img/yousei_midori.png" alt="緑の妖精">
        <img id="yousei-kiiro-img" src="https://peutes.github.io/toho_kouhakuma/img/yousei_kiiro.png" alt="黄色の妖精">
        <img id="reimu-shinbun-img" src="https://peutes.github.io/toho_kouhakuma/img/reimu_shinbun.png" alt="新聞">
    </div>


    <script>
        window.onload = function() {
            // --- 初期設定 ---
            const canvas = document.getElementById('game-canvas');
            const gameContainer = document.getElementById('game-container');
            const canvasWrapper = document.getElementById('game-canvas-wrapper');
            const ctx = canvas.getContext('2d');
            let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
            const scoreEl = document.getElementById('score');
            const livesEl = document.getElementById('lives');
            const powerEl = document.getElementById('power');
            const grazeEl = document.getElementById('graze');
            const bombsEl = document.getElementById('bombs');
            const bossInfoEl = document.getElementById('boss-info');
            const bossHealthBar = document.getElementById('boss-health-bar');
            const spellCardNameEl = document.getElementById('spell-card-name');
            const bossSpellLivesEl = document.getElementById('boss-spell-lives');
            const startScreen = document.getElementById('start-screen');
            const messageOverlay = document.getElementById('message-overlay');
            const dialogueBox = document.getElementById('dialogue-box');
            const bossDisplayName = document.getElementById('boss-display-name');
            const bossCutinEl = document.getElementById('boss-cutin');
            const bossCutinImg = document.getElementById('boss-cutin-img');
            const spellCardCutinNameEl = document.getElementById('spell-card-cutin-name');

            const POC_LINE_Y = 200;

            const youseiMidoriImg = document.getElementById('yousei-midori-img');
            const youseiKiiroImg = document.getElementById('yousei-kiiro-img');
            const reimuShinbunImg = document.getElementById('reimu-shinbun-img');
            const optionImg = document.getElementById('option-img');

            let preRenderedAssets = {};

            let gameStarted = false;
            let gameTime = 0;
            let score = 0;
            let firstEnemyKilled = false;
            const keys = {};
            let currentBossName = '';

            const isMobile = /Mobi|Android/i.test(navigator.userAgent);

            // --- ★ 修正: 画面リサイズ処理を全面的に書き換え ---
            function handleResize() {
                const isMobileSize = window.matchMedia("(max-width: 850px)").matches;

                if (isMobileSize) {
                    document.body.classList.add('mobile-layout');
                    // モバイルレイアウト: コンテナを画面全体に広げる
                    gameContainer.style.height = window.innerHeight + 'px';
                    gameContainer.style.width = '100vw';

                    // FlexboxがcanvasWrapperのサイズを決めるのを待ってからCanvasをスケーリング
                    setTimeout(() => {
                        const wrapperRect = canvasWrapper.getBoundingClientRect();
                        if (wrapperRect.width === 0 || wrapperRect.height === 0) return;

                        const canvasAspectRatio = canvas.width / canvas.height; // 600 / 800 = 0.75
                        const wrapperAspectRatio = wrapperRect.width / wrapperRect.height;

                        let newWidth, newHeight;

                        if (wrapperAspectRatio > canvasAspectRatio) {
                            // ラッパーが横長の場合、高さを基準に合わせる
                            newHeight = wrapperRect.height;
                            newWidth = newHeight * canvasAspectRatio;
                        } else {
                            // ラッパーが縦長の場合、幅を基準に合わせる
                            newWidth = wrapperRect.width;
                            newHeight = newWidth / canvasAspectRatio;
                        }

                        canvas.style.width = `${newWidth}px`;
                        canvas.style.height = `${newHeight}px`;

                    }, 50); // レイアウト計算のための僅かな遅延

                } else {
                    // PCレイアウト
                    document.body.classList.remove('mobile-layout');
                    gameContainer.style.height = '';
                    gameContainer.style.width = '';
                    canvas.style.width = '';
                    canvas.style.height = '';
                }
            }


            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', handleResize);

            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
            } else {
                document.getElementById('pc-controls').style.display = 'block';
            }

            let isDragging = false;
            let touchStartX, touchStartY;
            let playerStartX, playerStartY;
            let lastTap = 0;

            let sfx, music;
            function setupAudio() {
                try {
                    if (typeof Tone === 'undefined') {
                        console.error("Tone.js is not loaded yet.");
                        return false;
                    }
                    sfx = {
                        playerShot: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.08, sustain: 0, release: 0.1 } }).toDestination(),
                        bomb: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 1.5, sustain: 0, release: 1 } }).toDestination(),
                        enemyHit: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination(),
                        playerHit: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination(),
                        playerShatter: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 10, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                        powerUp: new Tone.Synth({ oscillator: {type: 'sine'}, envelope: {attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2}}).toDestination(),
                        graze: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                        laser: new Tone.Synth({ oscillator: { type: 'pwm', modulationFrequency: 0.2 }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.1, release: 0.2 } }).toDestination(),
                        spellClear: new Tone.Synth({ oscillator: {type: 'triangle8'}, envelope: {attack: 0.05, decay: 0.8, sustain: 0.2, release: 1.5}}).toDestination(),
                        bossDefeat: new Tone.NoiseSynth({noise: {type: 'brown'}, envelope: {attack: 0.1, decay: 3, sustain: 0.1, release: 2}}).toDestination(),
                    };
                    Object.values(sfx).forEach(synth => synth.volume.value = -15);
                    sfx.playerHit.volume.value = -5;
                    sfx.playerShatter.volume.value = -3;
                    sfx.graze.volume.value = -20;
                    sfx.spellClear.volume.value = -8;
                    sfx.bossDefeat.volume.value = -8;
                    sfx.powerUp.volume.value = -12;


                    music = {
                        stage: new Tone.Synth({ oscillator: { type: "fmsquare", harmonicity: 1.2, modulationIndex: 5 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
                        reimu: new Tone.Synth({ oscillator: { type: "fmsquare", modulationType: "sawtooth", harmonicity: 0.8 }, envelope: { attack: 0.02, decay: 0.4, sustain: 0.2, release: 0.2 } }).toDestination(),
                        marisa: new Tone.Synth({ oscillator: { type: "sawtooth", detune: 12 }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.1 } }).toDestination(),
                        drums: new Tone.MembraneSynth().toDestination(),
                        cymbal: new Tone.MetalSynth({ frequency: 250, envelope: { attack: 0.001, decay: 0.05, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
                        activeSeq: null
                    };
                    Object.values(music).forEach(instrument => {
                        if (instrument instanceof Tone.Synth || instrument instanceof Tone.PolySynth || instrument instanceof Tone.MonoSynth || instrument instanceof Tone.MembraneSynth || instrument instanceof Tone.MetalSynth) {
                            instrument.volume.value = -18;
                        }
                    });
                    music.drums.volume.value = -12;

                    return true;
                } catch (e) {
                    console.error("Error setting up audio:", e);
                    return false;
                }
            }

            function stopMusic() {
                try {
                    if (Tone.Transport.state === 'started') {
                        if (music.activeSeq) music.activeSeq.stop(0);
                        Tone.Transport.stop();
                        Tone.Transport.cancel();
                    }
                } catch(e) { /* do nothing */ }
            }

            function playMusic(theme) {
                try {
                    stopMusic();
                    let melody, synth, bpm;
                    switch(theme) {
                        case 'reimu':
                            melody = ['A4','G4','E4','D4', 'E4','G4','A4','C5', 'B4','A4','G4','E4', 'D4','E4','D4','C4'];
                            synth = music.reimu;
                            bpm = 168;
                            break;
                        case 'marisa':
                            melody = ['C5','E5','G5','C6', 'A5','G5','E5','G5', 'F5','A5','C6','F6', 'E6','D6','C6', null];
                            synth = music.marisa;
                            bpm = 185;
                            break;
                        default:
                            melody = ['G4', 'A#4', 'C5', 'D5', 'G4', 'D5', 'C5', 'A#4', 'G4', 'A#4', 'C5', 'A#4', 'G4', 'F4', 'G4', null];
                            synth = music.stage;
                            bpm = 175;
                    }
                    music.activeSeq = new Tone.Sequence((time, note) => {
                        if (note) synth.triggerAttackRelease(note, '8n', time);
                    }, melody, '4n').start(0);
                    new Tone.Loop(time => {
                        music.drums.triggerAttackRelease("C2", "8n", time);
                        music.cymbal.triggerAttackRelease("C4", "16n", time + Tone.Time('8n').toSeconds());
                    }, '4n').start(0);
                    Tone.Transport.bpm.value = bpm;
                    Tone.Transport.start();
                } catch (e) { /* do nothing */ }
            }

            const player = {
                x: canvas.width / 2, y: canvas.height - 100, width: 48, height: 48, speed: 6, lives: 100, power: 0, bombs: 3, graze: 0,
                hitboxRadius: 2, grazeRadius: 45, shootCooldown: 0, invincible: false, invincibleTimer: 0, bombing: false,
                isHitFlashing: false, hitFlashTimer: 0,
                img: document.getElementById('player-img'), options: [],
            };

            let bullets = [], enemyBullets = [], enemies = [], particles = [], vfx = [], powerUps = [], lasers = [], bombItems = [], scoreItems = [];
            let playerBombs = [];

            const boss = {
                x: canvas.width / 2, y: -100, width: 80, height: 80, speed: 2, active: false, visible: true, hp: 0, maxHp: 1,
                state: 'INACTIVE',
                phaseTimer: 0, phases: [], currentPhaseIndex: -1, img: null, targetX: canvas.width / 2, targetY: 150,
                familiars: [], trails: [], isBlazing: false, auraRadius: 50,
            };

            const stage = {
                timeline: [
                    { time: 120, type: 'cross_fairy_left', count: 10 },
                    { time: 180, type: 'cross_fairy_right', count: 10 },
                    { time: 360, type: 'big_fairy', side: 'center', count: 1 },
                    { time: 540, type: 'sunflower_wall', side: 'left', count: 5 },
                    { time: 600, type: 'sunflower_wall', side: 'right', count: 5 },
                    { time: 720, type: 'final_rush_fairy', side: 'v-shape', count: 15 },
                    { time: 900, type: 'boss', name: 'reimu' }
                ],
                nextEventIndex: 0, bossQueue: ['marisa']
            };

            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;

                if (gameStarted) {
                    if (e.repeat) return;

                    if (key === 'l') {
                        spawnBoss('reimu');
                    }
                    if (key === 'm') {
                        spawnBoss('marisa');
                    }
                    if (key === 'k') {
                         if (boss.active && boss.phases[boss.currentPhaseIndex]?.type === 'spell') {
                             boss.hp = 0;
                         }
                    }
                }
            });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvasWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvasWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            // --- ★ 修正: ゲーム開始処理を関数化し、タップイベント(touchend)にも対応 ---
            function startGame() {
                if (gameStarted) return; // 既に開始していたら何もしない

                // Tone.js (音声)のコンテキストを開始
                Tone.start().then(() => {
                    // 音声が利用可能な場合の処理
                    if (!sfx) { // sfxが未初期化の場合のみ初期化
                        if (!setupAudio()) console.error("効果音の初期化に失敗しました。");
                    }
                    // ゲーム開始
                    preRenderGraphics();
                    handleResize();
                    gameStarted = true;
                    startScreen.style.display = 'none';
                    resetGame();
                    gameLoop();
                }).catch(error => {
                    // 音声が利用不可の場合でもゲームは開始する
                    console.warn("音声コンテキストを開始できませんでした。音声なしでゲームを開始します。", error);
                    preRenderGraphics();
                    handleResize();
                    gameStarted = true;
                    startScreen.style.display = 'none';
                    resetGame();
                    gameLoop();
                });
            }

            startScreen.addEventListener('click', startGame);
            startScreen.addEventListener('touchend', (e) => {
                e.preventDefault(); // ダブルタップによるズームなどを防ぐ
                startGame();
            });

            // ★ 初期ロード時に一度呼び出し
            handleResize();

            function preRenderGraphics() {
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#008000', '#0000ff', '#9400d3', '#ff00ff', '#ffffff'];
                preRenderedAssets.stars = {};

                colors.forEach(color => {
                    const starCanvas = document.createElement('canvas');
                    const starSize = 24;
                    starCanvas.width = starSize;
                    starCanvas.height = starSize;
                    const starCtx = starCanvas.getContext('2d');
                    starCtx.fillStyle = color;
                    starCtx.shadowColor = color;
                    starCtx.shadowBlur = 8;
                    starCtx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const radius = starSize / 2;
                        starCtx.lineTo( radius + Math.cos((18 + i * 72) * Math.PI / 180) * radius, radius - Math.sin((18 + i * 72) * Math.PI / 180) * radius );
                        starCtx.lineTo( radius + Math.cos((54 + i * 72) * Math.PI / 180) * radius * 0.5, radius - Math.sin((54 + i * 72) * Math.PI / 180) * radius * 0.5 );
                    }
                    starCtx.closePath();
                    starCtx.fill();
                    preRenderedAssets.stars[color] = starCanvas;
                });
            }

            function resetGame() {
                gameTime = 0; score = 0;
                firstEnemyKilled = false;
                player.lives = 100; player.power = 0; player.graze = 0; player.bombs = 3;
                player.x = canvas.width / 2; player.y = canvas.height - 100;
                bullets = []; enemyBullets = []; enemies = []; particles = []; vfx = []; powerUps = []; lasers = []; bombItems = []; scoreItems = []; playerBombs = [];
                boss.active = false; stage.nextEventIndex = 0; stage.bossQueue = ['marisa'];
                updatePlayerOptions(); playMusic('stage'); updateUI();
            }

            function drawPlayer() {
                if (player.invincible && Math.floor(gameTime / 6) % 2 === 0) return;

                ctx.save();
                if (player.isHitFlashing) {
                    ctx.globalAlpha = player.hitFlashTimer / 10;
                    ctx.drawImage(player.img, player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'white';
                    ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
                }
                ctx.restore();

                ctx.drawImage(player.img, player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.hitboxRadius + 2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2); ctx.fill();

                player.options.forEach(opt => {
                    const x = player.x + opt.x; const y = player.y + opt.y;
                    ctx.drawImage(optionImg, x - 16, y - 16, 32, 32);
                });
            }

            function drawBullets() {
                bullets.forEach(b => {
                    ctx.fillStyle = b.color; ctx.shadowColor = b.color; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            function drawEnemyBullets() {
                enemyBullets.forEach(b => {
                    ctx.save();
                    ctx.globalAlpha = b.alpha || 1.0; ctx.translate(b.x, b.y); ctx.rotate(b.angle);
                    if (b.shape === 'amulet') {
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = b.amuletType === 'white' ? '#f0eada' : '#dc143c';
                        ctx.strokeStyle = b.amuletType === 'white' ? '#dc143c' : 'white';
                        ctx.lineWidth = 1.5;
                        const width = b.radius * 2; const height = b.radius * 4;
                        ctx.fillRect(-width / 2, -height / 2, width, height);
                        ctx.strokeRect(-width / 2, -height / 2, width, height);
                        ctx.save();
                        ctx.fillStyle = b.amuletType === 'white' ? '#dc143c' : 'white';
                        ctx.font = 'bold 9px DotGothic16';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.rotate(Math.PI / 2 + Math.PI);
                        ctx.fillText('博麗', 0, 0);
                        ctx.restore();
                    } else if (b.shape === 'star') {
                        const starTexture = preRenderedAssets.stars[b.color] || preRenderedAssets.stars['#ffffff'];
                        ctx.drawImage(starTexture, -b.radius, -b.radius, b.radius * 2, b.radius * 2);
                    }
                    else {
                        ctx.shadowColor = b.color; ctx.shadowBlur = 8;
                        ctx.fillStyle = b.color;
                        ctx.beginPath(); ctx.arc(0, 0, b.radius, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                });
                ctx.shadowBlur = 0;
            }

            function drawEnemies() {
                enemies.forEach(e => {
                    ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
                    if (e.img) { ctx.drawImage(e.img, -e.width / 2, -e.height / 2, e.width, e.height); }
                    else { ctx.fillStyle = e.color; ctx.fillRect(-e.width / 2, -e.height / 2, e.width, e.height); }
                    ctx.restore();
                });
            }

            function drawPowerUps() {
                powerUps.forEach(p => {
                    ctx.fillStyle = '#ff5555'; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px DotGothic16'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('P', p.x, p.y);
                });
            }

            function drawBombItems() {
                bombItems.forEach(b => {
                    ctx.fillStyle = '#8888ff'; ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px DotGothic16'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('B', b.x, b.y);
                });
            }

            function drawScoreItems() {
                scoreItems.forEach(s => {
                    ctx.fillStyle = '#44ff44'; ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px DotGothic16'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('S', s.x, s.y);
                });
            }

            function drawBoss() {
                if (!boss.active || !boss.visible || !boss.img) return;

                if (boss.isBlazing) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(148, 0, 211, 0.4)';
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(boss.x, boss.y, boss.auraRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.drawImage(boss.img, boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
            }

            function drawLasers() {
                lasers.forEach(l => {
                    ctx.save(); ctx.translate(l.x, l.y); ctx.rotate(l.angle); ctx.globalAlpha = l.alpha;
                    if (l.width > 20 && !l.isWarning) {
                        const grad = ctx.createLinearGradient(0, -l.width / 2, 0, l.width / 2);
                        grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                        grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                        grad.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                        grad.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
                        grad.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, -l.width / 2, canvas.height * 1.5, l.width);
                        const baseColor = l.color.replace('rgb(', '').replace(')', '');
                        const glowGrad = ctx.createLinearGradient(0, -l.width, 0, l.width);
                        glowGrad.addColorStop(0, `rgba(${baseColor}, 0)`);
                        glowGrad.addColorStop(0.5, `rgba(${baseColor}, 0.5)`);
                        glowGrad.addColorStop(1, `rgba(${baseColor}, 0)`);
                        ctx.fillStyle = glowGrad;
                        ctx.fillRect(0, -l.width, canvas.height * 1.5, l.width * 2);

                    } else { ctx.fillStyle = l.color; ctx.fillRect(0, -l.width / 2, canvas.height * 1.5, l.width); }
                    ctx.restore();
                });
            }

            function drawParticles() {
                particles.forEach(p => {
                    ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                });
            }

            function drawVFX() {
                vfx.forEach(v => {
                    v.draw(ctx);
                });
            }

            function drawPlayerBombs() {
                playerBombs.forEach(b => {
                    ctx.save();
                    ctx.globalAlpha = b.alpha;

                    const coreGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.radius / 3);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    coreGrad.addColorStop(1, 'rgba(173, 216, 230, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius / 3, 0, Math.PI * 2);
                    ctx.fill();

                    const outerGrad = ctx.createRadialGradient(b.x, b.y, b.radius * 0.7, b.x, b.y, b.radius);
                    outerGrad.addColorStop(0, 'rgba(0, 255, 255, 0)');
                    outerGrad.addColorStop(0.8, 'rgba(173, 216, 230, 0.7)');
                    outerGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = outerGrad;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 255, 255, ${b.alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                    ctx.translate(b.x, b.y);
                    ctx.rotate(gameTime * 0.15);

                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const angle = (Math.PI * 2 / 6) * i;
                        ctx.lineTo(Math.cos(angle) * b.radius * 1.1, Math.sin(angle) * b.radius * 1.1);
                        ctx.stroke();
                    }
                    ctx.restore();
                });
            }

            function drawTrails() {
                if (!boss.trails || boss.trails.length === 0) return;
                boss.trails.forEach(t => {
                    ctx.save();

                    ctx.fillStyle = `rgba(255, 0, 255, ${t.alpha * 0.3})`;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = `rgba(255, 255, 255, ${t.alpha * 0.9})`;
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            function drawFamiliars() {
                if (!boss.active || !boss.familiars) return;
                boss.familiars.forEach(f => {
                    if (f.draw) f.draw(ctx);
                });
            }

            function updateUI() {
                scoreEl.textContent = score; livesEl.textContent = 'x ' + player.lives; powerEl.textContent = player.power;
                grazeEl.textContent = player.graze; bombsEl.innerHTML = `&#x1F9A0; x ${player.bombs}`;
                if (boss.active) {
                    bossInfoEl.style.display = 'block';
                    const healthPercentage = Math.max(0, boss.hp / boss.maxHp);
                    bossHealthBar.style.width = `${healthPercentage * 100}%`;
                    bossDisplayName.innerHTML = currentBossName === 'reimu' ? 'BOSS ⛩️' : 'BOSS 🧙';
                    const remainingSpells = boss.phases.filter((p, i) => p.type === 'spell' && i >= boss.currentPhaseIndex).length;
                    bossSpellLivesEl.innerHTML = '&#x2605;'.repeat(remainingSpells);
                } else {
                    bossInfoEl.style.display = 'none'; spellCardNameEl.textContent = '';
                }
            }

            // --- 更新関数 ---
            function updatePlayer() {
                if (!isMobile) {
                    player.speed = keys['shift'] ? 6 : 9;
                    if (keys['arrowleft'] && player.x > player.width / 2) player.x -= player.speed;
                    if (keys['arrowright'] && player.x < canvas.width - player.width / 2) player.x += player.speed;
                    if (keys['arrowup'] && player.y > player.height / 2) player.y -= player.speed;
                    if (keys['arrowdown'] && player.y < canvas.height - player.height / 2) player.y += player.speed;
                }

                if (player.invincible) {
                    player.invincibleTimer--;
                    if (player.invincibleTimer <= 0) {
                        player.invincible = false;
                    }
                }

                if (player.isHitFlashing) {
                    player.hitFlashTimer--;
                    if(player.hitFlashTimer <= 0) {
                        player.isHitFlashing = false;
                    }
                }

                if (keys['z'] || (isMobile && isDragging)) { fireShot(); }
                if (player.shootCooldown > 0) player.shootCooldown--;
                if (keys['x']) {
                    fireBomb();
                    keys['x'] = false;
                }
            }

            function fireShot() {
                if (player.shootCooldown > 0) return;
                try { if(sfx) sfx.playerShot.triggerAttackRelease('A4', '8n'); } catch(e) {}
                player.shootCooldown = 5;
                const speed = 18; const shotLevel = Math.floor(player.power / 10); const shotCount = Math.min(5, 1 + shotLevel);
                if (shotCount === 1) { bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); }
                else if (shotCount === 2) { bullets.push({ x: player.x - 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); }
                else if (shotCount === 3) { bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x - 15, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 15, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); }
                else if (shotCount === 4) { bullets.push({ x: player.x - 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x - 20, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 20, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); }
                else if (shotCount >= 5) { bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x - 12, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 12, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x - 24, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); bullets.push({ x: player.x + 24, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#87CEFA', damage: 15 }); }
                player.options.forEach(opt => {
                    const missile = { x: player.x + opt.x, y: player.y + opt.y, radius: 6, color: '#32cd32', damage: 25, speed: 8, angle: -Math.PI / 2, turnRate: 0.05, target: null, life: 300, lockedOn: false,
                        update: function() {
                            this.life--; if (this.life <= 0) { const index = bullets.indexOf(this); if (index > -1) bullets.splice(index, 1); return; }
                            if (!this.lockedOn && (!this.target || this.target.hp <= 0)) { this.target = findClosestEnemy(this.x, this.y); }
                            if (this.target) {
                                const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x); let angleDiff = targetAngle - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2; while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                const dist = Math.hypot(this.target.x - this.x, this.target.y - this.y); if (!this.lockedOn && dist < 100 && Math.abs(angleDiff) < 0.2) { this.lockedOn = true; }
                                if (!this.lockedOn) { if (Math.abs(angleDiff) > this.turnRate) { this.angle += this.turnRate * Math.sign(angleDiff); } else { this.angle = targetAngle; } }
                            }
                            this.dx = Math.cos(this.angle) * this.speed; this.dy = Math.sin(this.angle) * this.speed; this.x += this.dx; this.y += this.dy;
                        }
                    };
                    bullets.push(missile);
                });
            }

            function fireBomb() {
                if (player.bombs > 0 && !player.bombing) {
                    try { if(sfx) sfx.bomb.triggerAttackRelease("2n"); } catch(e) {}
                    player.bombs--;
                    player.bombing = true;
                    player.invincible = true;
                    player.invincibleTimer = 240;

                    playerBombs.push({
                        x: player.x, y: player.y, vy: -3,
                        radius: 0, maxRadius: canvas.width, life: 120, alpha: 1, expandSpeed: 10
                    });
                }
            }

            function updateBullets() {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i]; if (!b) continue;
                    if (b.update) { b.update(); } else { b.x += b.dx; b.y += b.dy; }
                    if (b.y < -b.radius || b.x < -b.radius || b.x > canvas.width + b.radius || b.y > canvas.height + b.radius) { bullets.splice(i, 1); }
                }
            }

            function updatePowerUps() {
                powerUps.forEach((p, i) => {
                    const dist = Math.hypot(p.x - player.x, p.y - player.y);
                    if (dist < player.hitboxRadius + p.radius) {
                        if (player.power < 40) { player.power += 10; updatePlayerOptions(); } else { score += 1000; }
                        try { if(sfx) sfx.powerUp.triggerAttackRelease('C6', '16n'); } catch(e) {}
                        powerUps.splice(i, 1);
                    } else {
                        const dy = player.y - p.y; const dx = player.x - p.x;
                        if (dist < 80 || p.isHoming) { p.x += dx / dist * 8; p.y += dy / dist * 8; } else { p.y += p.speed; }
                        if (p.y > canvas.height + p.radius) powerUps.splice(i, 1);
                    }
                });
            }

            function updateBombItems() {
                bombItems.forEach((b, i) => {
                    const dist = Math.hypot(b.x - player.x, b.y - player.y);
                    if (dist < player.hitboxRadius + b.radius) {
                        if (player.bombs < 8) player.bombs++;
                        try { if(sfx) sfx.powerUp.triggerAttackRelease('A5', '16n'); } catch(e) {}
                        bombItems.splice(i, 1);
                    } else {
                        const dy = player.y - b.y;
                        const dx = player.x - b.x;
                        if (dist < 80 || b.isHoming) { b.x += dx / dist * 8; b.y += dy / dist * 8; } else { b.y += b.speed; }
                        if (b.y > canvas.height + b.radius) bombItems.splice(i, 1);
                    }
                });
            }

            function updateScoreItems() {
                scoreItems.forEach((s, i) => {
                    const dist = Math.hypot(s.x - player.x, s.y - player.y);
                    if (dist < player.hitboxRadius + s.radius) {
                        score += 5000;
                        try { if(sfx) sfx.powerUp.triggerAttackRelease('E6', '16n'); } catch(e) {}
                        scoreItems.splice(i, 1);
                    } else {
                        const dy = player.y - s.y;
                        const dx = player.x - s.x;
                        if (dist < 80 || s.isHoming) { s.x += dx / dist * 8; s.y += dy / dist * 8; } else { s.y += s.speed; }
                        if (s.y > canvas.height + s.radius) scoreItems.splice(i, 1);
                    }
                });
            }

            function updateItemCollectionState() {
                 if (player.y < POC_LINE_Y) {
                    powerUps.forEach(p => p.isHoming = true);
                    bombItems.forEach(b => b.isHoming = true);
                    scoreItems.forEach(s => s.isHoming = true);
                }
            }


            function updatePlayerBombs() {
                for (let i = playerBombs.length - 1; i >= 0; i--) {
                    const b = playerBombs[i];
                    if (b.radius < b.maxRadius) {
                        b.radius += b.expandSpeed;
                    }
                    b.y += b.vy;

                    b.life--;
                    if (b.life < 30) {
                        b.alpha = b.life / 30;
                    }
                    if (b.life <= 0) {
                        playerBombs.splice(i, 1);
                        player.bombing = false;
                        continue;
                    }

                    for (let j = enemyBullets.length - 1; j >= 0; j--) {
                        const eb = enemyBullets[j];
                        if (Math.hypot(eb.x - b.x, eb.y - b.y) < b.radius) {
                            createExplosion(eb.x, eb.y, '#87CEFA', 3);
                            enemyBullets.splice(j, 1);
                            score += 10;
                        }
                    }

                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (Math.hypot(e.x - b.x, e.y - b.y) < b.radius + e.width / 2) {
                            e.hp -= 100;
                        }
                    }

                    if (boss.active && Math.hypot(boss.x - b.x, boss.y - b.y) < b.radius + boss.width / 2) {
                        boss.hp -= 40;
                    }
                }
            }

            function updateEnemyBullets() {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const b = enemyBullets[i];
                    try {
                        if (b.update) b.update();
                        else { b.x += b.dx; b.y += b.dy; }
                        if (b.x < -b.radius - 20 || b.x > canvas.width + b.radius + 20 || b.y < -b.radius - 20 || b.y > canvas.height + b.radius + 20) {
                            enemyBullets.splice(i, 1);
                        }
                    } catch(e) {
                        enemyBullets.splice(i, 1);
                    }
                }
            }

            function updateLasers() {
                for (let i = lasers.length - 1; i >= 0; i--) {
                    const l = lasers[i];
                    try {
                        if (l.update) l.update();
                        l.timer--;
                        if (l.timer < 30) {
                            l.alpha = l.timer / 30;
                        }
                        if (l.timer <= 0) {
                            lasers.splice(i, 1);
                        }
                    } catch (e) {
                        lasers.splice(i, 1);
                    }
                }
            }

            function updateEnemies() {
                enemies.forEach((e, i) => {
                    try { e.update();
                        if (e.hp <= 0) {
                            try { if(sfx) sfx.enemyHit.triggerAttackRelease('C2', '8n'); } catch(err) {}
                            score += e.score;

                            if (!firstEnemyKilled) {
                                spawnPowerUp(e.x, e.y);
                                firstEnemyKilled = true;
                            } else {
                                const dropRoll = Math.random();
                                if (dropRoll < 0.20) {
                                    spawnPowerUp(e.x, e.y);
                                } else if (dropRoll < 0.50) {
                                    spawnScoreItem(e.x, e.y);
                                } else if (dropRoll < 0.55) {
                                    spawnBombItem(e.x, e.y);
                                }
                            }

                            createExplosion(e.x, e.y, '#fff', 20);
                            enemies.splice(i, 1);
                        } else if (e.y > canvas.height + e.height) { enemies.splice(i, 1); }
                    } catch (err) { enemies.splice(i, 1); }
                });
            }

            function updateFamiliars() {
                if (!boss.active || !boss.familiars) return;
                for (let i = boss.familiars.length - 1; i >= 0; i--) {
                    const f = boss.familiars[i];
                    if (f.update) {
                        f.update();
                    }
                    if(f.life !== undefined) {
                        f.life--;
                        if (f.life <= 0) {
                            boss.familiars.splice(i, 1);
                        }
                    }
                }
            }

            function updateVFX() {
                for (let i = vfx.length - 1; i >= 0; i--) {
                    const v = vfx[i];
                    if (v.update()) {
                        vfx.splice(i, 1);
                    }
                }
            }

            function updateTrails() {
                if (boss.trails && boss.trails.length > 0) {
                    for (let i = boss.trails.length - 1; i >= 0; i--) {
                        const t = boss.trails[i];
                        t.life--;
                        t.alpha = Math.min(1, t.alpha + 0.1);

                        if (t.life < 40) {
                            t.alpha = t.life / 40;
                        }

                        if (t.life === 58) {
                            for(let j=0; j < 1; j++) {
                                const angle = t.angle + (Math.random() - 0.5) * Math.PI;
                                createEnemyBullet(t.x, t.y, 2 + Math.random(), angle, rainbowColor(), 9, 'star');
                            }
                        }

                        if (t.life <= 0) {
                            boss.trails.splice(i, 1);
                        }
                    }
                }
            }

            function updateParticles() {
                particles.forEach((p, i) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.alpha -= 0.02;
                    if (p.alpha <= 0) {
                        particles.splice(i, 1);
                    }
                });
            }

            function updateBoss() {
                if (!boss.active) return;

                if (boss.sparkState === 'MOVING') {
                    const dx = boss.targetX - boss.x;
                    const dy = boss.targetY - boss.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 1) {
                        boss.x = boss.targetX;
                        boss.y = boss.targetY;
                        boss.sparkState = 'IDLE';
                    } else {
                        boss.x += dx * 0.15;
                        boss.y += dy * 0.15;
                    }
                }

                switch (boss.state) {
                    case 'ENTERING':
                        boss.y += boss.speed;
                        if (boss.y >= 150) {
                            boss.y = 150;
                            boss.state = 'DIALOGUE';
                            handleBossDialogue(currentBossName);
                        }
                        break;
                    case 'ATTACKING':
                        if (boss.currentPhaseIndex < 0 || boss.currentPhaseIndex >= boss.phases.length) return;
                        const currentPhase = boss.phases[boss.currentPhaseIndex];
                        if (!currentPhase) return;

                        if (boss.sparkState !== 'MOVING') {
                            const dx = boss.targetX - boss.x, dy = boss.targetY - boss.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist > boss.speed) {
                                boss.x += dx / dist * boss.speed;
                                boss.y += dy / dist * boss.speed;
                            }
                        }

                        boss.phaseTimer++;
                        if (currentPhase.type === 'spell') {
                            if (boss.hp <= 0 && boss.state !== 'PHASE_ENDING') {
                                boss.state = 'PHASE_ENDING';
                                setTimeout(() => {
                                    startNextBossPhase();
                                }, 1000);
                            }
                            if (boss.canAttack && boss.state === 'ATTACKING') {
                                currentPhase.card.func();
                            }
                        }
                        break;
                }
            }

            function updateStage() {
                if (boss.active) return;
                if (stage.nextEventIndex < stage.timeline.length) {
                    const event = stage.timeline[stage.nextEventIndex];
                    if (gameTime >= event.time) {
                        if (event.type === 'boss') {
                            spawnBoss(event.name);
                        }
                        else { spawnEnemies(event); }
                        stage.nextEventIndex++;
                    }
                }
            }

            function checkCollisions() {
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const b = bullets[bi]; if (!b) continue;
                    let hit = false;
                    for (let ei = enemies.length - 1; ei >= 0; ei--) {
                        const e = enemies[ei];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.width / 2 + b.radius) { e.hp -= b.damage || 10; hit = true; break; }
                    }
                    if (hit) {
                        bullets.splice(bi, 1);
                        try { if(sfx) sfx.enemyHit.triggerAttackRelease('C3', '8n'); } catch(err) {}
                        createHitVFX(b.x, b.y, '#87CEFA');
                        continue;
                    }
                    if (boss.active && boss.state === 'ATTACKING' && !boss.invincible && boss.visible && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.width / 2 + b.radius) {
                        boss.hp -= b.damage || 10;
                        bullets.splice(bi, 1);
                        try { if(sfx) sfx.enemyHit.triggerAttackRelease('C3', '8n'); } catch(e) {}
                        createHitVFX(b.x, b.y, '#ff8888');
                    }
                }
                if (player.invincible) return;

                enemyBullets.forEach(b => {
                    if (!b.grazed && Math.hypot(b.x - player.x, b.y - player.y) < player.grazeRadius) { b.grazed = true; player.graze++; score += 100; try { if(sfx) sfx.graze.triggerAttackRelease("C7", "32n"); } catch(e) {} }
                    if (!b.isWarning && Math.hypot(b.x - player.x, b.y - player.y) < player.hitboxRadius + b.radius) playerHit();
                });
                lasers.forEach(l => {
                    if (l.isWarning || l.alpha < 0.5) return;
                    const playerDist = Math.abs((l.x - player.x) * Math.sin(l.angle) - (l.y - player.y) * Math.cos(l.angle));
                    const dx = player.x - l.x; const dy = player.y - l.y; const dotProduct = dx * Math.cos(l.angle) + dy * Math.sin(l.angle);
                    if (dotProduct > 0 && playerDist < l.width / 2 + player.hitboxRadius) { playerHit(); }
                });
                if(boss.trails){
                    boss.trails.forEach(t => {
                        if (t.alpha > 0.5 && Math.hypot(player.x - t.x, player.y - t.y) < t.radius + player.hitboxRadius) { playerHit(); }
                    });
                }
                 if(boss.familiars) {
                      boss.familiars.forEach(f => {
                          if (f.type === 'photo' && f.state === 'active' && !player.invincible) {
                              if (player.x > f.x && player.x < f.x + f.width && player.y > f.y && player.y < f.y + f.height) {
                                  playerHit();
                              }
                          }
                      });
                 }
                if (boss.isBlazing && Math.hypot(player.x - boss.x, player.y - boss.y) < boss.auraRadius + player.hitboxRadius) {
                    playerHit();
                }
                if (boss.active && !player.invincible && Math.hypot(player.x - boss.x, player.y - boss.y) < boss.width / 2 + player.hitboxRadius) { playerHit(); }
            }

            function playerHit() {
                if (player.invincible) return;
                try {
                    sfx.playerHit.triggerAttackRelease("16n");
                    sfx.playerShatter.triggerAttackRelease("C3", "8n");
                } catch(e) {}

                player.lives--;
                updatePlayerOptions();
                createPlayerHitVFX(player.x, player.y);
                triggerScreenShake(10, 20);

                player.isHitFlashing = true;
                player.hitFlashTimer = 10;

                if (player.lives < 0) {
                    gameOver();
                } else {
                    player.invincible = true;
                    player.invincibleTimer = 180;
                }
            }

            function spawnScoreItem(x, y) { scoreItems.push({ x, y, speed: 1.5, radius: 10, isHoming: false }); }
            function spawnPowerUp(x, y) { powerUps.push({ x, y, speed: 1.5, radius: 10, isHoming: false }); }
            function spawnBombItem(x, y) { bombItems.push({ x, y, speed: 1.5, radius: 10, isHoming: false }); }

            function spawnEnemies(event) {
                for (let i = 0; i < event.count; i++) {
                    let enemy;
                    switch(event.type) {
                        case 'cross_fairy_left':
                        case 'cross_fairy_right':
                            enemy = { hp: 10, score: 250, shootCooldown: 60, shootTimer: 0, width: 50, height: 50, img: youseiMidoriImg, angle: 0, moveTimer: i * 15,
                                isLeft: event.type === 'cross_fairy_left',
                                update() {
                                    this.moveTimer++;
                                    this.x = this.isLeft ? (this.moveTimer * 2) : (canvas.width - this.moveTimer * 2);
                                    this.y = 50 + this.moveTimer * 1.5;
                                    this.shootTimer++;
                                    if (this.shootTimer > this.shootCooldown) {
                                        this.shootTimer = 0;
                                        const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                        for(let j = -1; j <= 1; j++) {
                                            createEnemyBullet(this.x, this.y, 3.5, angleToPlayer + j * 0.2, '#00c800', 5, 'circle');
                                        }
                                    }
                                }
                            };
                            break;
                        case 'big_fairy':
                            enemy = {
                                hp: 1000,
                                score: 2000,
                                shootCooldown: 4, shootTimer: 0, x: canvas.width/2, y: -50, width: 80, height: 80, img: youseiKiiroImg, angle: 0, moveTimer: 0,
                                state: 'entering',
                                update() {
                                    if(this.state === 'entering') {
                                        this.y += 2;
                                        if(this.y >= 150) this.state = 'firing';
                                    } else if (this.state === 'firing') {
                                        this.shootTimer++;
                                        this.moveTimer++;
                                        if(this.shootTimer > this.shootCooldown) {
                                            this.shootTimer = 0;
                                            const baseAngle = this.moveTimer * 0.05;
                                            for(let j=0; j<2; j++) {
                                                createEnemyBullet(this.x, this.y, 4, baseAngle + j * Math.PI, 'yellow', 8, 'circle');
                                            }
                                        }
                                        if(this.moveTimer > 240) {
                                            this.state = 'leaving';
                                        }
                                    } else if (this.state === 'leaving') {
                                        this.y -= 3;
                                    }
                                }
                            };
                            break;
                        case 'sunflower_wall':
                            enemy = { hp: 100, score: 500, shootCooldown: 50, shootTimer: i * 10, x: (canvas.width / (event.count + 1)) * (i + 1), y: -30, width: 50, height: 50, img: youseiKiiroImg, angle: 0, moveTimer: 0,
                                update() {
                                    if (this.y < 100) this.y += 1;
                                    this.angle += 0.03; this.shootTimer++;
                                    if (this.shootTimer > this.shootCooldown) {
                                        this.shootTimer = 0;
                                        for (let j = 0; j < 8; j++) { createEnemyBullet(this.x, this.y, 3, (Math.PI * 2 / 8) * j + this.angle, 'orange', 6, 'circle'); }
                                    }
                                }
                            };
                            break;
                        case 'final_rush_fairy':
                            enemy = { hp: 10, score: 200, shootCooldown: 50, shootTimer: 0, x: 0, y: 0, width: 50, height: 50, img: youseiMidoriImg, angle: 0, moveTimer: i * 10,
                                update() {
                                    this.moveTimer++;
                                    const side = i % 2 === 0 ? 1 : -1;
                                    this.x = canvas.width / 2 + side * this.moveTimer * 3;
                                    this.y = 50 + this.moveTimer * 2;
                                    this.shootTimer++;
                                    if (this.shootTimer > this.shootCooldown) {
                                        this.shootTimer = 0;
                                        const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                        for(let j = -1; j <= 1; j++) {
                                            createEnemyBullet(this.x, this.y, 4, angleToPlayer + j * 0.25, 'pink', 5, 'circle');
                                        }
                                    }
                                }
                            };
                            break;
                    }
                    if (enemy) enemies.push(enemy);
                }
            }

            function spawnBoss(name) {
                enemies = [];
                enemyBullets = [];
                vfx = [];
                boss.familiars = [];
                if(boss.trails) boss.trails = [];
                currentBossName = name;
                boss.active = true;
                boss.visible = true;
                boss.y = -100;
                boss.x = canvas.width / 2;
                boss.state = 'ENTERING';
                boss.currentPhaseIndex = -1;
                playMusic(name);
                if (name === 'reimu') {
                    boss.img = document.getElementById('reimu-img');
                    boss.phases = [ { type: 'spell', hp: 20000, card: { name: '夢符「二重結界」', func: duplexBarrier } }, { type: 'spell', hp: 20000, card: { name: 'お札「新聞拡張団調伏」', func: newspaperSubjugation } }, { type: 'spell', hp: 20000, card: { name: '結界「パパラッチ撃退結界」', func: paparazziBoundary } }, { type: 'spell', hp: 20000, card: { name: '夢符「封魔陣」', func: evilSealingCircle } }, { type: 'spell', hp: 20000, card: { name: '霊符「夢想封印 集」', func: fantasySealClump } }, { type: 'spell', hp: 20000, card: { name: '神域「神霊大結界」', func: greatDivineBarrier } }, { type: 'spell', hp: 20000, card: { name: '霊符「夢想妙珠」', func: fantasySeal } }, ];
                } else if (name === 'marisa') {
                    boss.img = document.getElementById('marisa-img');
                    boss.phases = [ { type: 'spell', hp: 20000, card: { name: '魔符「ミルキーウェイ」', func: milkyWay } }, { type: 'spell', hp: 20000, card: { name: '魔符「スターダストレヴァリエ」', func: stardustReverie } }, { type: 'spell', hp: 20000, card: { name: '恋符「ノンディレクショナルレーザー」', func: nonDirectionalLaser } }, { type: 'spell', hp: 20000, card: { name: '恋符「マスタースパーク」', func: masterSpark } }, { type: 'spell', hp: 20000, card: { name: '魔砲「ファイナルスパーク」', func: finalSpark } }, { type: 'spell', hp: 20000, card: { name: '星符「メテオニックシャワー」', func: meteonicShower } }, { type: 'spell', hp: 20000, card: { name: '彗星「ブレイジングスター」', func: blazingStar } }, ];
                }
            }

            function handleBossDialogue(name) {
                const bossNameJP = name === 'reimu' ? '博麗霊夢' : '霧雨魔理沙';
                showOverlayMessage(`${bossNameJP}が現れた...`, 180);
                setTimeout(() => {
                    let dialogueLines = name === 'reimu' ? [ '<p><strong>霊夢:</strong> ん？ この妖気…ただの河童じゃないわね。神社の裏でコソコソと…何をしているのかしら？</p>', '<p><strong>にとり:</strong> ひゃっ！？ は、博麗の巫女…！ い、いや、これはただのガラクタでして…そう、ガラクタ！けして怪しいものじゃ…！</p>', '<p><strong>霊夢:</strong> その割には随分と物々しい気配じゃない。まあ、何だっていいわ。神社の敷地内で騒ぎを起こすなら、容赦はしない。それが幻想郷のルールよ。</p>', '<p><strong>にとり:</strong> うぅ…やっぱりこうなるのか…！ でも、この『超弩級スーパーすごいマシン』だけは渡せない！これは河童の技術の結晶なんだから！</p>', '<p><strong>霊夢:</strong> はいはい、威勢がいいのは結構。そのすごいマシンとやらで、どこまでやれるか見せてもらうわ！</p>' ]
                                             : [ '<p><strong>魔理沙:</strong> おっと、こんな森の奥で派手な花火を上げてるのはどこのどいつだ？ なんだか面白そうな匂いがプンプンするぜ！</p>', '<p><strong>にとり:</strong> げっ！ あんたは白黒の魔法使い…！ な、なんでこんな所に…！</p>', '<p><strong>魔理沙:</strong> なんでって、そりゃ魔法の実験に決まってるだろ？ それよりお前が持ってるソレ、すっごい魔力を感じるな。ちょっと貸してみろ！</p>', '<p><strong>にとり:</strong> だ、だめ！ これは私のきゅーかんばーぴっくるす…じゃなくて！私の血と汗と涙の結晶なんだから！あんたみたいな泥棒に渡してたまるもんですか！</p>', '<p><strong>魔理沙:</strong> 泥棒とはひどい言い草だな。私はただ借りるだけだぜ、永遠にな！ 弾幕ごっこで決めようぜ、それが手っ取り早い！</p>' ];
                    let currentLineIndex = 0;
                    dialogueBox.style.display = 'block';
                    const showNextLine = () => {
                        if (currentLineIndex < dialogueLines.length) {
                            dialogueBox.innerHTML = `<div>${dialogueLines[currentLineIndex]}</div><div class="continue-prompt">▼ タップして続行</div>`;
                            currentLineIndex++;
                        } else {
                            dialogueBox.style.display = 'none';
                            dialogueBox.removeEventListener('click', showNextLine);
                            dialogueBox.removeEventListener('touchend', showNextLine); // ★ 修正: touchendも削除
                            startNextBossPhase();
                        }
                    };
                    // ★ 修正: touchendにも対応
                    dialogueBox.addEventListener('click', showNextLine);
                    dialogueBox.addEventListener('touchend', showNextLine);
                    showNextLine();
                }, 3000);
            }

            function startNextBossPhase() {
                if (boss.hp <= 0 && boss.state !== 'DEFEATED') {
                    score += 50000;
                    createSpellCardClearVFX(boss);
                    enemyBullets.forEach(b => {
                        spawnScoreItem(b.x, b.y);
                    });
                    enemyBullets = [];
                    for(let i = 0; i < 2; i++) spawnPowerUp(boss.x + (Math.random() - 0.5) * 100, boss.y + (Math.random() - 0.5) * 100);
                    if (Math.random() < 0.5) spawnBombItem(boss.x + (Math.random() - 0.5) * 100, boss.y + (Math.random() - 0.5) * 100);
                }

                vfx = [];
                boss.currentPhaseIndex++;
                if (boss.currentPhaseIndex >= boss.phases.length) {
                    bossDefeated();
                    return;
                }
                const currentPhase = boss.phases[boss.currentPhaseIndex];
                boss.hp = currentPhase.hp; boss.maxHp = currentPhase.hp; boss.phaseTimer = 0;
                boss.invincible = true; boss.visible = true;
                boss.state = 'INTRO';
                boss.familiars = [];
                boss.trails = [];
                boss.sparkState = null;
                boss.activeWarningLaser = null;
                boss.isAiming = false;

                boss.canAttack = false;

                if (currentPhase.type === 'spell') {
                    createMagicCircle(boss.x, boss.y, 300, 9999, currentBossName === 'reimu' ? 'rgba(255, 100, 100, 0.3)' : 'rgba(200, 100, 255, 0.3)');
                    spellCardNameEl.textContent = currentPhase.card.name;
                    spellCardCutinNameEl.textContent = currentPhase.card.name;
                    bossCutinImg.src = boss.img.src;
                    bossCutinEl.classList.add('animate');
                    setTimeout(() => {
                        boss.state = 'ATTACKING';
                        boss.canAttack = true;
                        boss.invincible = false;
                        bossCutinEl.classList.remove('animate');
                    }, 2500);
                } else {
                    boss.state = 'ATTACKING';
                    boss.canAttack = true;
                    boss.invincible = false;
                }

                boss.targetX = canvas.width / 2;
                boss.targetY = 150;
            }

            function bossDefeated() {
                boss.state = 'DEFEATED';
                boss.visible = false;
                createBossDefeatVFX(boss.x, boss.y);
                score += 100000;
                boss.active = false;
                boss.isBlazing = false;

                for(let i = 0; i < 5; i++) spawnPowerUp(boss.x + (Math.random() - 0.5) * 200, boss.y + (Math.random() - 0.5) * 200);
                for(let i = 0; i < 3; i++) spawnBombItem(boss.x + (Math.random() - 0.5) * 200, boss.y + (Math.random() - 0.5) * 200);

                enemyBullets.forEach(b => {
                    if (Math.random() < 0.2) {
                        spawnScoreItem(b.x, b.y);
                    }
                });

                enemies = []; enemyBullets = []; lasers = []; boss.familiars = []; boss.trails = [];
                showOverlayMessage("STAGE CLEAR!!", 180);
                setTimeout(() => { handleVictoryDialogue(currentBossName); }, 3000);
            }

            function handleVictoryDialogue(name) {
                let dialogueLines = name === 'reimu' ? [ '<p><strong>霊夢:</strong> くっ…この私が…！ このお賽銭泥棒め！</p>', '<p><strong>にとり:</strong> や、やったー！ これで私の技術力が証明された！</p>' ]
                                             : [ '<p><strong>魔理沙:</strong> なんだその火力は！？ 普通じゃないぜ…！</p>', '<p><strong>にとり:</strong> ふふん、河童の科学力は世界一ィィ！</p>' ];
                let currentLineIndex = 0;
                dialogueBox.style.display = 'block';
                const showNextLine = () => {
                    if (currentLineIndex < dialogueLines.length) {
                        dialogueBox.innerHTML = `<div>${dialogueLines[currentLineIndex]}</div><div class="continue-prompt">▼ タップして続行</div>`;
                        currentLineIndex++;
                    } else {
                        dialogueBox.style.display = 'none';
                        dialogueBox.removeEventListener('click', showNextLine);
                        dialogueBox.removeEventListener('touchend', showNextLine); // ★ 修正: touchendも削除
                        if (stage.bossQueue.length > 0) {
                            const nextBoss = stage.bossQueue.shift();
                            showOverlayMessage("WARNING!", 120);
                            setTimeout(() => spawnBoss(nextBoss), 2000);
                        } else {
                            showOverlayMessage("ALL CLEAR!", 300);
                            stopMusic();
                            setTimeout(() => { gameStarted = false; startScreen.style.display = 'flex'; }, 5000);
                        }
                    }
                };
                // ★ 修正: touchendにも対応
                dialogueBox.addEventListener('click', showNextLine);
                dialogueBox.addEventListener('touchend', showNextLine);
                showNextLine();
            }

            // --- Reimu Spell Cards ---
            function duplexBarrier() {
                if(boss.phaseTimer % 15 === 0) createAura(boss, 100, 15, 'rgba(255, 0, 0, 0.5)');
                if (boss.phaseTimer % 4 === 0) { const spiralArms = 2; for (let i = 0; i < spiralArms; i++) { const angle = boss.phaseTimer * 0.08 + (i * Math.PI * 2 / spiralArms); createEnemyBullet(boss.x, boss.y, 3, angle, null, 7, 'amulet'); } }
                if (boss.phaseTimer % 15 === 0) { const ringBulletCount = 20; const ringRadius = 280; const baseAngle = -boss.phaseTimer * 0.025; for (let i = 0; i < ringBulletCount; i++) { const angle = baseAngle + (i * Math.PI * 2 / ringBulletCount); const sx = boss.x + Math.cos(angle) * ringRadius; const sy = boss.y + Math.sin(angle) * ringRadius; createEnemyBullet(sx, sy, 2.5, angle, null, 8, 'amulet'); } }
            }
            function fantasySeal() {
                 if (boss.phaseTimer % 20 === 0) {
                     createAura(boss, 120, 20, 'rgba(255, 105, 180, 0.4)');
                     for (let i = 0; i < 8; i++) {
                         const angle = (i * Math.PI * 2 / 8) + boss.phaseTimer * 0.05;
                         const bullet = createEnemyBullet(boss.x, boss.y, 0, angle, null, 10, 'amulet');
                         bullet.speed = 2.5; bullet.turnRate = 0.025; bullet.life = 150;
                         bullet.update = function() {
                             this.life--; if (this.life <= 0) { for (let k = 0; k < 8; k++) { createEnemyBullet(this.x, this.y, 4, (k * Math.PI * 2 / 8), null, 4, 'amulet'); } const index = enemyBullets.indexOf(this); if (index > -1) enemyBullets.splice(index, 1); return; }
                             const targetAngle = Math.atan2(player.y - this.y, player.x - this.x); let angleDiff = targetAngle - this.angle;
                             while (angleDiff > Math.PI) angleDiff -= Math.PI * 2; while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                             this.angle += Math.max(-this.turnRate, Math.min(this.turnRate, angleDiff));
                             this.dx = Math.cos(this.angle) * this.speed; this.dy = Math.sin(this.angle) * this.speed; this.x += this.dx; this.y += this.dy;
                         }
                     }
                 }
            }
            function evilSealingCircle() {
                 if (boss.phaseTimer % 150 === 1) {
                     const circle = {
                         x: player.x, y: player.y, radius: 250, life: 300, spawnCooldown: 0, rotation: Math.random() * Math.PI * 2, type: 'sealingCircle',
                         update: function() {
                             this.spawnCooldown--;
                             if (this.life > 60 && this.spawnCooldown <= 0) {
                                 this.spawnCooldown = 6; this.rotation += 0.06;
                                 for (let j = 0; j < 10; j++) {
                                     const angle = this.rotation + (j * Math.PI * 2 / 10); const sx = this.x + Math.cos(angle) * this.radius; const sy = this.y + Math.sin(angle) * this.radius;
                                     const bullet = createEnemyBullet(sx, sy, 3, angle + Math.PI, null, 6, 'amulet');
                                     createAura({x: sx, y: sy}, 20, 10, 'rgba(255, 136, 136, 0.5)');
                                     const self = this;
                                     bullet.update = function() {
                                         this.x += this.dx; this.y += this.dy;
                                         const dist = Math.hypot(this.x - self.x, this.y - self.y);
                                         if (dist > self.radius + 10) { const index = enemyBullets.indexOf(this); if (index > -1) enemyBullets.splice(index, 1); }
                                     };
                                 }
                             }
                         },
                         draw: function(ctx) {
                             ctx.save();
                             ctx.globalAlpha = Math.min(1, (300 - this.life) / 60) * Math.min(1, this.life / 60);
                             ctx.strokeStyle = '#ff8888'; ctx.lineWidth = 3;
                             ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke();
                             ctx.restore();
                         }
                     };
                     boss.familiars.push(circle);
                 }
            }
            function greatDivineBarrier() {
                if (boss.phaseTimer === 1) {
                    for (let i = 0; i < 4; i++) {
                        const orb = {
                            color1: (i % 2 === 0) ? '#dc143c' : '#333333',
                            color2: '#ffffff',
                            angle: i * (Math.PI * 2 / 4), radius: 200, shootCooldown: 0, rotation: 0, x: 0, y: 0, life: 9999,
                            update: function() {
                                this.angle += 0.024;
                                this.rotation += 0.1; this.x = boss.x + Math.cos(this.angle) * this.radius; this.y = boss.y + Math.sin(this.angle) * this.radius;
                                this.shootCooldown--;
                                if (this.shootCooldown <= 0) {
                                    this.shootCooldown = 15; const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                    for (let j = -1; j <= 1; j++) { createEnemyBullet(this.x, this.y, 4, angleToPlayer + j * 0.2, null, 6, 'amulet'); }
                                }
                            },
                            draw: function(ctx) {
                                ctx.save();
                                ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                                ctx.fillStyle = this.color1; ctx.beginPath(); ctx.arc(0, -10, 10, 0, Math.PI, true); ctx.fill();
                                ctx.fillStyle = this.color2; ctx.beginPath(); ctx.arc(0, 10, 10, 0, Math.PI, false); ctx.fill();
                                ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.strokeStyle = '#333'; ctx.stroke();
                                ctx.fillStyle = this.color2; ctx.beginPath(); ctx.arc(0, -10, 4, 0, Math.PI * 2); ctx.fill();
                                ctx.fillStyle = this.color1; ctx.beginPath(); ctx.arc(0, 10, 4, 0, Math.PI * 2); ctx.fill();
                                ctx.restore();
                            }
                        };
                        boss.familiars.push(orb);
                    }
                }
                if (boss.phaseTimer % 25 === 0) { const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + (Math.random() - 0.5) * 0.2; createEnemyBullet(boss.x, boss.y, 5, null, 12, 'amulet'); }
            }
            function newspaperSubjugation() {
                if (boss.phaseTimer % 120 === 1) {
                    const familiar = {
                        x: player.x - 100, y: player.y - 125, width: 200, height: 250, life: 150, spawnTime: 90, state: 'warning', type: 'photo',
                        update: function() {
                            if (this.state === 'warning' && this.life <= this.spawnTime) {
                                this.state = 'active';
                                const bulletSpeed = 3, bulletRadius = 4, density = 25;
                                for (let x = this.x; x < this.x + this.width; x += density) { createEnemyBullet(x, this.y, bulletSpeed, Math.PI / 2, null, bulletRadius, 'amulet'); }
                                for (let x = this.x; x < this.x + this.width; x += density) { createEnemyBullet(x, this.y + this.height, bulletSpeed, -Math.PI / 2, null, bulletRadius, 'amulet'); }
                                for (let y = this.y; y < this.y + this.height; y += density) { createEnemyBullet(this.x, y, bulletSpeed, 0, null, bulletRadius, 'amulet'); }
                                for (let y = this.y; y < this.y + this.height; y += density) { createEnemyBullet(this.x + this.width, y, bulletSpeed, Math.PI, null, bulletRadius, 'amulet'); }
                            }
                        },
                        draw: function(ctx) {
                            ctx.save();
                            if (this.state === 'warning') {
                                const fadeTime = 30; let alpha = this.life < fadeTime ? this.life / fadeTime : 1;
                                ctx.fillStyle = `rgba(255, 0, 0, ${0.1 * alpha})`; ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * alpha})`;
                                ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height);
                            } else {
                                ctx.globalAlpha = this.life < 30 ? this.life / 30 : 1;
                                ctx.drawImage(reimuShinbunImg, this.x, this.y, this.width, this.height);
                            }
                            ctx.restore();
                        }
                    };
                    boss.familiars.push(familiar);
                }
            }
            function paparazziBoundary() {
                if (boss.phaseTimer % 150 === 1) { // Horizontal walls
                    const gapSize = 120; const gapY = Math.random() * (canvas.height - gapSize);
                    for (let y = 0; y < canvas.height; y += 20) {
                        if (y > gapY && y < gapY + gapSize) continue;
                        const b1 = createEnemyBullet(0, y, 3, 0, null, 5, 'amulet');
                        b1.angle = Math.PI / 2; // Rotate sprite
                        const b2 = createEnemyBullet(canvas.width, y, 3, Math.PI, null, 5, 'amulet');
                        b2.angle = Math.PI / 2; // Rotate sprite
                    }
                }
                if (boss.phaseTimer % 150 === 75) { // Vertical walls
                    const gapSize = 120; const gapX = Math.random() * (canvas.width - gapSize);
                    for (let x = 0; x < canvas.width; x += 20) {
                        if (x > gapX && x < gapX + gapSize) continue;
                        const b3 = createEnemyBullet(x, 0, 3, Math.PI / 2, null, 5, 'amulet');
                        b3.angle = 0; // Keep sprite vertical
                        const b4 = createEnemyBullet(x, canvas.height, 3, -Math.PI / 2, null, 5, 'amulet');
                        b4.angle = 0; // Keep sprite vertical
                    }
                }
            }
            function fantasySealClump() {
                if ((boss.phaseTimer % 300) < 240) {
                    if (boss.phaseTimer % 6 === 0) {
                        const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                        for (let i = -2; i <= 2; i++) {
                            const bullet = createEnemyBullet(boss.x, boss.y, 4.5, angleToPlayer + (i * 0.1), null, 8, 'amulet');
                            bullet.turnRate = 0.012; bullet.speed = 4.5;
                            bullet.update = function() {
                                const targetAngle = Math.atan2(player.y - this.y, player.x - this.x); let angleDiff = targetAngle - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2; while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                this.angle += Math.max(-this.turnRate, Math.min(this.turnRate, angleDiff));
                                this.dx = Math.cos(this.angle) * this.speed; this.dy = Math.sin(this.angle) * this.speed; this.x += this.dx; this.y += this.dy;
                            }
                        }
                    }
                }
                if (boss.phaseTimer % 30 === 0) { const ways = 12; const baseAngle = gameTime * 0.02; for (let i = 0; i < ways; i++) { const angle = baseAngle + (i * Math.PI * 2 / ways); createEnemyBullet(boss.x, boss.y, 3, '#ffffff', 14); } }
            }

            const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#008000', '#0000ff', '#9400d3', '#ff00ff'];
            function rainbowColor() { return rainbowColors[Math.floor(Math.random() * rainbowColors.length)]; }

            function milkyWay() {
                if (boss.phaseTimer % 2 === 0) {
                    const angle = boss.phaseTimer * 0.1; const dist = 50 + (boss.phaseTimer % 100);
                    const x = boss.x + Math.cos(angle) * dist; const y = boss.y + Math.sin(angle) * dist;
                    const bullet = createEnemyBullet(x, y, 2, angle + Math.PI / 2, rainbowColor(), 8, 'star');
                    createAura(bullet, 15, 10, bullet.color);
                }
                if (boss.phaseTimer % 60 === 0) {
                    const familiar = { x: Math.random() * canvas.width, y: 100, life: 120,
                        update: function() { if (this.life > 0 && this.life % 10 === 0) { const angle = Math.atan2(player.y - this.y, player.x - this.x); createEnemyBullet(this.x, this.y, 4, angle, '#ffff00', 12, 'star'); } },
                        draw: function(ctx) { ctx.fillStyle = 'yellow'; ctx.shadowColor = 'yellow'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }
                    };
                    boss.familiars.push(familiar);
                }
            }
            function stardustReverie() {
                if (gameTime % 4 < 3) {
                    const x = Math.random() * canvas.width; const y = Math.random() * canvas.height;
                    const bullet = createEnemyBullet(x, y, 0, 0, rainbowColor(), 12, 'star');
                    bullet.alpha = 0; bullet.life = 125;
                    bullet.update = function() {
                        this.life--; this.alpha = this.life > 100 ? 1 - ((this.life - 100) / 25) : this.life / 100;
                        if (this.life === 100) { this.angle = Math.random() * Math.PI * 2; this.speed = 2; this.dx = Math.cos(this.angle) * this.speed; this.dy = Math.sin(this.angle) * this.speed; }
                        if (this.life < 100) { this.x += this.dx; this.y += this.dy; }
                        if (this.life <= 0) enemyBullets.splice(enemyBullets.indexOf(this), 1);
                    }
                }
            }
            function nonDirectionalLaser() {
                const starSizes = [6, 10, 14];
                if (boss.phaseTimer % 120 === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    createAura(boss, 300, 30, 'rgba(255,255,100,0.5)');
                    for (let i = 0; i < 7; i++) {
                        try { if (sfx) sfx.laser.triggerAttackRelease('A3', '1s'); } catch(e) {}
                        createLaser(boss.x, boss.y, 12, angle + (i * Math.PI * 2 / 7), 100, 'rgb(255,255,100)');
                    }
                }
                if (boss.phaseTimer % 30 === 0) { const ways = 32; const baseAngle = boss.phaseTimer * 0.03; for (let i = 0; i < ways; i++) { const angle = baseAngle + (i * Math.PI * 2 / ways); createEnemyBullet(boss.x, boss.y, 3, angle, rainbowColor(), starSizes[i % 3], 'star'); } }
                if (boss.phaseTimer % 30 === 15) { const ways = 32; const baseAngle = -boss.phaseTimer * 0.03; for (let i = 0; i < ways; i++) { const angle = baseAngle + (i * Math.PI * 2 / ways); createEnemyBullet(boss.x, boss.y, 2.5, angle, rainbowColor(), starSizes[i % 3], 'star'); } }
                if (boss.phaseTimer % 2 === 0) { const angle = Math.random() * Math.PI * 2; const speed = 1 + Math.random() * 2; createEnemyBullet(boss.x, boss.y, speed, angle, '#ffff00', 5, 'star'); }
            }

            function masterSpark() {
                const cycleTime = 300;
                const localTime = boss.phaseTimer % cycleTime;

                const aimDuration = 30;
                const waitDuration = 150;
                const fireTime = aimDuration + waitDuration;

                if (localTime === 1) {
                    boss.sparkState = 'MOVING';
                    boss.targetX = Math.random() * (canvas.width - 200) + 100;
                    boss.targetY = Math.random() * 100 + 100;

                    boss.isAiming = true;
                    boss.sparkAimStartTime = boss.phaseTimer;
                    boss.sparkLockedAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    boss.activeWarningLaser = createLaser(boss.x, boss.y, 4, boss.sparkLockedAngle, fireTime + 1, 'rgba(255,100,255,0.5)', true);
                }

                if (boss.isAiming) {
                    createChargingVFX(boss);
                    const timeSinceAimStart = boss.phaseTimer - boss.sparkAimStartTime;

                    if (timeSinceAimStart <= aimDuration) {
                        const aimedAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        if (boss.activeWarningLaser) {
                            boss.activeWarningLaser.angle = aimedAngle;
                            boss.activeWarningLaser.x = boss.x;
                            boss.activeWarningLaser.y = boss.y;
                        }
                        boss.sparkLockedAngle = aimedAngle;
                    }

                    if (timeSinceAimStart > aimDuration) {
                        boss.isAiming = false;
                        if (boss.activeWarningLaser) {
                            boss.activeWarningLaser.angle = boss.sparkLockedAngle;
                        }
                    }
                }

                const timeSinceAimStart = boss.phaseTimer - boss.sparkAimStartTime;
                if (boss.sparkState !== 'FIRED' && timeSinceAimStart === fireTime) {
                    boss.sparkState = 'FIRED';
                    if (boss.activeWarningLaser) {
                        boss.activeWarningLaser.timer = 1;
                    }
                    try { if (sfx) sfx.laser.triggerAttackRelease('A2', '1.5s'); } catch(e) {}
                    const mainLaser = createLaser(boss.x, boss.y, 60, boss.sparkLockedAngle, 120, 'rgb(255,100,255)');
                    createLaserBeamVFX(mainLaser);
                }

                if (boss.phaseTimer % 8 === 0) {
                    for (let i = 0; i < 3; i++) {
                        const angle = (boss.phaseTimer * 0.05) + i * (Math.PI * 2 / 3);
                        createEnemyBullet(boss.x, boss.y, 2, angle, rainbowColor(), 16, 'star');
                    }
                }
            }

            function finalSpark() {
                const cycleTime = 300;
                const localTime = boss.phaseTimer % cycleTime;

                const aimDuration = 30;
                const waitDuration = 90;
                const fireTime = aimDuration + waitDuration;
                const starBulletDuration = 120;

                if (localTime === 1) {
                    boss.sparkState = 'MOVING';
                    boss.targetX = canvas.width / 2;
                    boss.targetY = 120;

                    boss.isAiming = true;
                    boss.sparkAimStartTime = boss.phaseTimer;
                    boss.sparkLockedAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    boss.activeWarningLaser = createLaser(boss.x, boss.y, 6, boss.sparkLockedAngle, fireTime + 1, 'rgba(255,100,255,0.3)', true);
                }

                if (boss.isAiming) {
                    createChargingVFX(boss);
                    const timeSinceAimStart = boss.phaseTimer - boss.sparkAimStartTime;

                    if (timeSinceAimStart <= aimDuration) {
                        const aimedAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        if (boss.activeWarningLaser) {
                            boss.activeWarningLaser.angle = aimedAngle;
                            boss.activeWarningLaser.x = boss.x;
                            boss.activeWarningLaser.y = boss.y;
                        }
                        boss.sparkLockedAngle = aimedAngle;
                    }

                    if (timeSinceAimStart > aimDuration) {
                        boss.isAiming = false;
                         if (boss.activeWarningLaser) {
                             boss.activeWarningLaser.angle = boss.sparkLockedAngle;
                         }
                    }
                }

                const timeSinceAimStart = boss.phaseTimer - boss.sparkAimStartTime;
                if (boss.sparkState !== 'FIRED' && timeSinceAimStart === fireTime) {
                    boss.sparkState = 'FIRED';
                    if (boss.activeWarningLaser) {
                        boss.activeWarningLaser.timer = 1;
                    }
                    try { if (sfx) sfx.laser.triggerAttackRelease('A1', '2.5s'); } catch(e) {}

                    const mainLaser = createLaser(boss.x, boss.y, 80, boss.sparkLockedAngle, 180, 'rgb(255,100,255)');
                    createLaserBeamVFX(mainLaser);
                    mainLaser.baseAngle = boss.sparkLockedAngle;
                    mainLaser.startTime = gameTime;
                    mainLaser.sweepDirection = (player.x < canvas.width / 2) ? 1 : -1;
                    mainLaser.totalTimer = 180;

                    mainLaser.update = function() {
                        const elapsedTime = gameTime - this.startTime;
                        const progress = Math.min(1, elapsedTime / this.totalTimer);
                        const sweepRange = Math.PI / 3.5;
                        this.angle = this.baseAngle + this.sweepDirection * Math.sin(progress * Math.PI) * sweepRange;
                    }
                }

                const timeSinceFire = timeSinceAimStart - fireTime;
                if (boss.sparkState === 'FIRED' && timeSinceFire > 0 && timeSinceFire <= starBulletDuration) {
                    if (gameTime % 3 === 0) {
                        const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                        for (let i = -1; i <= 1; i += 1) {
                            const bullet = createEnemyBullet(boss.x, boss.y, 4, angleToPlayer, rainbowColor(), 8, 'star');
                            bullet.spawnTime = gameTime;
                            bullet.baseAngle = angleToPlayer;
                            bullet.waveDirection = i;
                            bullet.speed = 4;

                            bullet.update = function() {
                                const timeAlive = gameTime - this.spawnTime;
                                const travelDistance = timeAlive * this.speed;
                                const centerX = boss.x + Math.cos(this.baseAngle) * travelDistance;
                                const centerY = boss.y + Math.sin(this.baseAngle) * travelDistance;

                                const perpAngle = this.baseAngle + Math.PI / 2;
                                const waveAmplitude = 60;
                                const waveFrequency = this.waveDirection === 0 ? 0 : 0.1;
                                const offset = this.waveDirection * Math.sin(timeAlive * waveFrequency) * waveAmplitude;

                                this.x = centerX + Math.cos(perpAngle) * offset;
                                this.y = centerY + Math.sin(perpAngle) * offset;

                                if (this.x < -this.radius || this.x > canvas.width + this.radius || this.y < -this.radius || this.y > canvas.height + this.radius) {
                                    const index = enemyBullets.indexOf(this);
                                    if (index > -1) enemyBullets.splice(index, 1);
                                }
                            };
                        }
                    }
                }
            }

            function meteonicShower() {
                if (boss.phaseTimer % 5 === 0) {
                    for(let i=0; i<4; i++) {
                        const x = Math.random() * canvas.width; const angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                        const bullet = createEnemyBullet(x, 0, 6, angle, rainbowColor(), 12, 'star');
                        createAura(bullet, 20, 15, bullet.color);
                    }
                }
            }

            function blazingStar() {
                if (boss.phaseTimer === 1) {
                    boss.isBlazing = true;
                    boss.dashState = 'pre-dashing';
                    boss.targetX = (Math.random() < 0.5 ? -50 : canvas.width + 50);
                    boss.targetY = Math.random() * canvas.height;
                    boss.x = canvas.width / 2;
                    boss.y = 150;
                }

                if (boss.dashState === 'pre-dashing') {
                    const dx = boss.targetX - boss.x;
                    const dy = boss.targetY - boss.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 25) {
                        boss.x = boss.targetX; boss.y = boss.targetY;
                        boss.dashState = 'dashing';
                        boss.dashTimer = 85;
                        const targetAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        boss.dx = Math.cos(targetAngle) * 8.4;
                        boss.dy = Math.sin(targetAngle) * 8.4;
                    } else {
                        boss.x += dx / dist * 30;
                        boss.y += dy / dist * 30;
                    }
                }

                if (boss.dashState === 'dashing') {
                    boss.x += boss.dx;
                    boss.y += boss.dy;
                    boss.dashTimer--;
                    const trailSegment = {
                        x: boss.x, y: boss.y, life: 60, alpha: 0, radius: 30,
                        angle: Math.atan2(boss.dy, boss.dx)
                    };
                    if(boss.trails) boss.trails.push(trailSegment);
                    if (boss.dashTimer <= 0 || boss.x < -100 || boss.x > canvas.width + 100 || boss.y < -100 || boss.y > canvas.height + 100) {
                        boss.dashState = 'waiting';
                        boss.dashWaitTimer = 60;
                    }
                } else if (boss.dashState === 'waiting') {
                    boss.dashWaitTimer--;
                    if(boss.dashWaitTimer <= 0) {
                        boss.dashState = 'idle';
                        boss.phaseTimer = 0;
                    }
                }
            }

            function createEnemyBullet(x, y, speed, angle, color, radius, shape = 'circle') {
                const bullet = { x, y, radius, color, shape, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, angle: shape === 'amulet' ? angle : 0, grazed: false };
                if (shape === 'amulet') {
                    bullet.amuletType = (boss.amuletTypeCounter || 0) % 2 === 0 ? 'red' : 'white';
                    boss.amuletTypeCounter = (boss.amuletTypeCounter || 0) + 1;
                }
                enemyBullets.push(bullet); return bullet;
            }

            function createLaser(x, y, width, angle, timer, color, isWarning = false) {
                const laser = { x, y, width, angle, timer, color, alpha: 1, isWarning, totalTimer: timer };
                lasers.push(laser); return laser;
            }

            function createExplosion(x, y, color, count, life = 1) {
                const c = color.match(/\w\w/g).map((c) => parseInt(c, 16));
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 2;
                    particles.push({ x, y, radius: Math.random() * 3 + 1, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, r: c[0], g: c[1], b: c[2], alpha: 1 * life });
                }
            }

            function createHitVFX(x, y, color = '#ffffff') {
                 vfx.push({
                    x, y, radius: 10, maxRadius: 40, life: 15, alpha: 0.8, color: color,
                    update: function() { this.radius += (this.maxRadius - this.radius) * 0.2; this.life--; this.alpha = this.life / 15; return this.life <= 0; },
                    draw: function(ctx) { ctx.strokeStyle = this.color; ctx.lineWidth = 3 * this.alpha; ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1;}
                });
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 1;
                    vfx.push({
                        x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 20, alpha: 1, radius: Math.random() * 2 + 1, color: '#ffff77',
                        update: function() { this.x += this.vx; this.y += this.vy; this.vx *= 0.95; this.vy *= 0.95; this.life--; this.alpha = this.life/20; return this.life <= 0;},
                        draw: function(ctx) { ctx.fillStyle = this.color; ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
                    });
                }
            }

            function createPlayerHitVFX(x, y) {
                 vfx.push({
                    x, y, radius: 20, maxRadius: 120, life: 10, alpha: 1,
                    update: function() { this.radius += (this.maxRadius - this.radius) * 0.3; this.life--; this.alpha = this.life / 10; return this.life <= 0; },
                    draw: function(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();}
                });
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 8 + 2;
                    const gravity = 0.1;
                    vfx.push({
                        x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 40, alpha: 1,
                        update: function() { this.x += this.vx; this.y += this.vy; this.vy += gravity; this.life--; this.alpha = this.life/40; return this.life <= 0;},
                        draw: function(ctx) {
                            ctx.strokeStyle = `rgba(255, 100, 100, ${this.alpha})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3);
                            ctx.stroke();
                        }
                    });
                }
            }

            function createSpellCardClearVFX() {
                 try { if(sfx) sfx.spellClear.triggerAttackRelease("C6", "2s"); } catch(e) {}
                 vfx.push({
                     life: 30, alpha: 1.0,
                     update: function() { this.life--; this.alpha = (this.life/30); return this.life <= 0; },
                     draw: function(ctx) { ctx.fillStyle = `rgba(255, 255, 224, ${this.alpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                 });
                 vfx.push({
                     x: boss.x, y: boss.y, radius: 30, maxRadius: canvas.width * 1.2, life: 60, alpha: 1,
                     update: function() { this.radius += (this.maxRadius - this.radius) * 0.08; this.life--; this.alpha = this.life / 60; return this.life <= 0;},
                     draw: function(ctx) { ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`; ctx.lineWidth = 20 * this.alpha; ctx.shadowColor = '#fff'; ctx.shadowBlur = 30; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0; }
                 });
                 for(let i=0; i < 50; i++) {
                     vfx.push({
                        x: Math.random() * canvas.width, y: Math.random() * canvas.height, life: Math.random() * 60 + 30, alpha: 0, maxAlpha: Math.random() * 0.5 + 0.5, radius: Math.random() * 2 + 1, maxLife: 0,
                        update: function() { if(this.maxLife === 0) this.maxLife = this.life; this.life--; this.alpha = Math.sin(Math.PI * (1 - this.life / this.maxLife)) * this.maxAlpha; return this.life <= 0;},
                        draw: function(ctx) { ctx.fillStyle = '#fff'; ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
                     });
                 }
            }
             function createBossDefeatVFX(x, y) {
                let explosionCount = 0;
                function createStagedExplosion() {
                    if (explosionCount >= 5) {
                        setTimeout(() => {
                            createExplosion(x, y, '#ffffff', 300, 2);
                            triggerScreenShake(30, 60);
                        }, 200);
                        return;
                    }
                    createExplosion(x + (Math.random() - 0.5) * 80, y + (Math.random() - 0.5) * 80, rainbowColor(), 100);
                    triggerScreenShake(15, 20);
                    explosionCount++;
                    setTimeout(createStagedExplosion, 200);
                }
                try { if(sfx) sfx.bossDefeat.triggerAttackRelease("4n"); } catch(e) {}
                createStagedExplosion();
            }

            function createMagicCircle(x, y, radius, duration, color) {
                vfx.push({
                    x, y, radius, life: duration, maxLife: duration, rotation: Math.random() * Math.PI * 2,
                    update: function() { this.life--; this.rotation += 0.005; this.x = boss.x; this.y = boss.y; return this.life <= 0; },
                    draw: function(ctx) {
                        const alpha = Math.min(1, (this.maxLife - this.life) / 60) * 0.5;
                        ctx.save(); ctx.globalAlpha = alpha; ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                        ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                        for(let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            ctx.moveTo(0,0);
                            ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                        }
                        ctx.stroke(); ctx.restore();
                    }
                });
            }

            function createAura(target, radius, duration, color) {
                vfx.push({
                    target, radius, life: duration, maxLife: duration,
                    update: function() { this.life--; return this.life <= 0 || !this.target; },
                    draw: function(ctx) {
                        const alpha = Math.sin(Math.PI * (this.life / this.maxLife)) * 0.8;
                        ctx.fillStyle = color; ctx.globalAlpha = alpha; ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, this.radius, 0, Math.PI * 2);
                        ctx.fill(); ctx.globalAlpha = 1;
                    }
                });
            }

             function createChargingVFX(target) {
                if (gameTime % 2 !== 0) return;
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 100 + 100;
                vfx.push({
                    startX: target.x + Math.cos(angle) * dist, startY: target.y + Math.sin(angle) * dist,
                    target, life: 30, maxLife: 30,
                    update: function() { this.life--; return this.life <= 0;},
                    draw: function(ctx) {
                        const progress = 1 - (this.life / this.maxLife);
                        const x = this.startX + (this.target.x - this.startX) * progress;
                        const y = this.startY + (this.target.y - this.startY) * progress;
                        ctx.fillStyle = rainbowColor(); ctx.globalAlpha = 1 - progress;
                        ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                });
            }

            function createLaserBeamVFX(laser) {
                 vfx.push({
                    laser, life: laser.timer,
                    update: function() { this.life--; return this.life <= 0;},
                    draw: function(ctx) {
                        if (!this.laser || this.laser.timer <= 0) return;
                        ctx.save();
                        ctx.translate(this.laser.x, this.laser.y); ctx.rotate(this.laser.angle);
                        ctx.globalAlpha = this.laser.alpha * 0.5;
                        for(let i=0; i<3; i++) {
                           const offset = (gameTime * 20 + i * 100) % (canvas.height * 1.5);
                           const wave = Math.sin((offset * 0.1) + (i * Math.PI / 2)) * this.laser.width * 0.3;
                           ctx.fillStyle = rainbowColor();
                           ctx.beginPath();
                           ctx.arc(offset, wave, 5, 0, Math.PI * 2);
                           ctx.fill();
                        }
                        ctx.restore();
                    }
                 });
            }

            function triggerScreenShake(intensity, duration) {
                screenShake.intensity = Math.max(screenShake.intensity, intensity);
                screenShake.duration = Math.max(screenShake.duration, duration);
            }

            function updateScreenShake() {
                if(screenShake.duration > 0) {
                    screenShake.duration--;
                    screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.intensity *= 0.95;
                } else {
                    screenShake.x = 0;
                    screenShake.y = 0;
                    screenShake.intensity = 0;
                }
            }

            function showOverlayMessage(html, duration) {
                messageOverlay.innerHTML = html; messageOverlay.style.display = 'flex';
                setTimeout(() => { messageOverlay.style.display = 'none'; }, duration * 1000 / 60);
            }

            function gameOver() {
                gameStarted = false; stopMusic(); showOverlayMessage("GAME OVER", 300);
                setTimeout(() => { startScreen.style.display = 'flex'; }, 5000);
            }

            function handleTouchStart(e) {
                e.preventDefault(); if (!gameStarted) return;
                const touch = e.touches[0]; const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
                const touchX = (touch.clientX - rect.left) * scaleX; const touchY = (touch.clientY - rect.top) * scaleY;
                const currentTime = new Date().getTime(); const tapLength = currentTime - lastTap;
                if (tapLength < 300 && tapLength > 0) { fireBomb(); lastTap = 0; isDragging = false; return; }
                lastTap = currentTime; isDragging = true;
                touchStartX = touchX; touchStartY = touchY; playerStartX = player.x; playerStartY = player.y;
            }

            function handleTouchMove(e) {
                e.preventDefault(); if (!isDragging || !gameStarted) return;
                const touch = e.touches[0]; const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
                const touchX = (touch.clientX - rect.left) * scaleX; const touchY = (touch.clientY - rect.top) * scaleY;
                const deltaX = touchX - touchStartX; const deltaY = touchY - touchStartY;
                player.x = playerStartX + deltaX; player.y = playerStartY + deltaY;
                player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
                player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));
            }

            function handleTouchEnd(e) { e.preventDefault(); if (!isDragging || !gameStarted) return; isDragging = false; }

            function updatePlayerOptions() {
                player.options = []; const numOptions = Math.min(4, Math.floor(player.power / 10));
                switch (numOptions) {
                    case 1: player.options.push({ x: -30, y: 10 }); break;
                    case 2: player.options.push({ x: -30, y: 10 }); player.options.push({ x: 30, y: 10 }); break;
                    case 3: player.options.push({ x: -40, y: 10 }, { x: 40, y: 10 }, { x: 0, y: 30 }); break;
                    case 4: player.options.push({ x: -40, y: 10 }, { x: 40, y: 10 }, { x: -25, y: 30 }, { x: 25, y: 30 }); break;
                }
            }

            function findClosestEnemy(x, y) {
                let closest = null; let closestDist = Infinity;
                const checkTarget = (target) => { const dist = Math.hypot(x - target.x, y - target.y); if (dist < closestDist) { closestDist = dist; closest = target; } };
                if (boss.active && boss.visible) { checkTarget(boss); }
                if (!closest) { enemies.forEach(checkTarget); }
                return closest;
            }

            function gameLoop() {
                try {
                    if (!gameStarted) return;

                    ctx.save();
                    updateScreenShake();
                    ctx.translate(screenShake.x, screenShake.y);

                    ctx.clearRect(-screenShake.intensity, -screenShake.intensity, canvas.width + screenShake.intensity * 2, canvas.height + screenShake.intensity * 2);

                    updateStage(); updatePlayer(); updateBullets(); updatePowerUps(); updateBombItems(); updateScoreItems(); updatePlayerBombs();
                    updateItemCollectionState();
                    updateEnemyBullets(); updateLasers(); updateEnemies(); updateBoss(); updateFamiliars(); updateTrails();
                    updateParticles();
                    updateVFX();
                    checkCollisions();

                    drawVFX();
                    drawTrails();
                    drawEnemies(); drawBoss(); drawFamiliars();
                    drawPlayer();
                    drawBullets(); drawPowerUps(); drawBombItems(); drawScoreItems(); drawLasers(); drawEnemyBullets();
                    drawParticles(); drawPlayerBombs();

                    ctx.restore();

                    updateUI();

                    gameTime++;
                    requestAnimationFrame(gameLoop);
                } catch (e) {
                    console.error("An error occurred in the game loop:", e);
                    if (gameStarted) { requestAnimationFrame(gameLoop); }
                }
            }
        };
    </script>
</body>
</html>
