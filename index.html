<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ±æ–¹AIç´…ç™½é­” ~ Dual Boss Shooter ~</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="AIãŒç”Ÿæˆã—ãŸæ±æ–¹Projecté¢¨ã®å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã€‚è‡ªæ©Ÿã¯æ²³åŸã«ã¨ã‚Šï¼ç«‹ã¡ã¯ã ã‹ã‚‹åšéº—éœŠå¤¢ã¨éœ§é›¨é­”ç†æ²™ã‚’æ’ƒç ´ã—ã‚ˆã†ã€‚PCã§ã‚‚ã‚¹ãƒãƒ›ã§ã‚‚éŠã¹ã¾ã™ã€‚">
    <meta name="keywords" content="æ±æ–¹, æ±æ–¹Project, å¼¾å¹•, ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°, STG, ã‚²ãƒ¼ãƒ , ç„¡æ–™, AI, Gemini, åšéº—éœŠå¤¢, éœ§é›¨é­”ç†æ²™, ã«ã¨ã‚Š">
    <meta name="author" content="Gemini">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="æ±æ–¹AIç´…ç™½é­” ~ Dual Boss Shooter ~">
    <meta property="og:description" content="AIãŒç”Ÿæˆã—ãŸæ±æ–¹Projecté¢¨ã®å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã€‚è‡ªæ©Ÿã¯æ²³åŸã«ã¨ã‚Šï¼ç«‹ã¡ã¯ã ã‹ã‚‹åšéº—éœŠå¤¢ã¨éœ§é›¨é­”ç†æ²™ã‚’æ’ƒç ´ã—ã‚ˆã†ã€‚">
    <meta property="og:image" content="https://peutes.github.io/toho_kouhakuma/img/title.png">
    <meta property="og:url" content="https://peutes.github.io/toho_kouhakuma/">

    <!-- Twitter Card -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://peutes.github.io/toho_kouhakuma/">
    <meta property="twitter:title" content="æ±æ–¹AIç´…ç™½é­” ~ Dual Boss Shooter ~">
    <meta property="twitter:description" content="AIãŒç”Ÿæˆã—ãŸæ±æ–¹Projecté¢¨ã®å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã€‚è‡ªæ©Ÿã¯æ²³åŸã«ã¨ã‚Šï¼ç«‹ã¡ã¯ã ã‹ã‚‹åšéº—éœŠå¤¢ã¨éœ§é›¨é­”ç†æ²™ã‚’æ’ƒç ´ã—ã‚ˆã†ã€‚">
    <meta property="twitter:image" content="https://peutes.github.io/toho_kouhakuma/img/title.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "æ±æ–¹AIç´…ç™½é­” ~ Dual Boss Shooter ~",
      "description": "AIãŒç”Ÿæˆã—ãŸæ±æ–¹Projecté¢¨ã®å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã€‚è‡ªæ©Ÿã¯æ²³åŸã«ã¨ã‚Šï¼ç«‹ã¡ã¯ã ã‹ã‚‹åšéº—éœŠå¤¢ã¨éœ§é›¨é­”ç†æ²™ã‚’æ’ƒç ´ã—ã‚ˆã†ã€‚",
      "genre": ["Shooter", "Bullet Hell", "Danmaku"],
      "playMode": "SinglePlayer",
      "applicationCategory": "Game",
      "operatingSystem": "Windows, MacOS, Linux, iOS, Android, Web browser",
      "author": {
        "@type": "Person",
        "name": "Gemini"
      }
    }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        html, body {
            background-color: #000;
            color: #fff;
            font-family: 'DotGothic16', sans-serif;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* ãƒšãƒ¼ã‚¸å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
        }
        #game-wrapper {
             display: flex;
             justify-content: center;
             align-items: center;
             width: 100%;
             height: 100%;
        }
        #game-container {
            display: flex;
            border: 2px solid #fff;
            box-shadow: 0 0 20px #ff00ff;
            width: 804px; /* 600 + 200 + 4 */
            height: 804px;
        }
        #game-canvas-wrapper {
            position: relative;
            width: 600px;
            height: 800px;
            overflow: hidden;
        }
        #game-canvas {
            background-color: #010517;
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            animation: scroll-bg 30s linear infinite;
        }
        @keyframes scroll-bg {
            from { background-position-y: 0px; }
            to { background-position-y: 550px; }
        }
        #sidebar {
            width: 200px;
            background-color: #1c0c1c;
            padding: 20px;
            box-sizing: border-box;
            border-left: 2px solid #fff;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #sidebar h2 {
            margin-top: 0;
            color: #ff5a5a;
            text-shadow: 0 0 5px #ff5a5a;
        }
        #sidebar .info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            margin-bottom: 15px;
        }
        #sidebar .info-label {
            color: #aaa;
        }
        #sidebar .info-value {
            color: #fff;
        }
        #boss-info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 5px 10px;
            box-sizing: border-box;
            background: rgba(28, 12, 28, 0.7);
            z-index: 50;
            border-bottom: 1px dashed #fff;
        }
        #boss-name-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #boss-name-container h3 {
            font-size: 14px;
            margin: 0;
        }
        #boss-spell-lives {
            color: #ffc4e1;
            font-size: 14px;
        }
        #boss-health-bar-container {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #fff;
            border-radius: 3px;
            margin-top: 3px;
        }
        #boss-health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff);
            border-radius: 2px;
            transition: width 0.2s ease-out;
        }
        #spell-card-name {
            margin-top: 3px;
            font-size: 12px;
            height: 16px;
            text-align: right;
            color: #ffc4e1;
        }
        #player-images, #boss-images {
            display: none;
        }
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
        }
        #start-screen img {
            max-width: 85%;
            height: auto;
        }
        #start-screen p {
            font-size: 24px;
        }
        #start-screen .controls {
            margin-top: 20px;
            text-align: left;
        }
        #start-screen .controls p {
            font-size: 15px;
            margin: 4px 0;
        }
        #message-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            text-align: center;
            text-shadow: 0 0 20px #f0f;
            z-index: 90;
        }
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: calc(100% - 40px);
            height: 150px;
            border: 1px solid #66f;
            padding: 10px;
            padding-bottom: 25px;
            background: rgba(0,0,50,0.8);
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.4;
            cursor: pointer;
            z-index: 80;
            overflow-y: scroll;
        }
        #dialogue-box::-webkit-scrollbar { width: 8px; }
        #dialogue-box::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #dialogue-box::-webkit-scrollbar-thumb { background-color: #888; border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
        #dialogue-box::-webkit-scrollbar-thumb:hover { background-color: #aaa; }
        @keyframes blinker { 50% { opacity: 0.5; } }
        .continue-prompt {
            position: absolute;
            bottom: 5px;
            right: 10px;
            color: #ffff88;
            font-weight: bold;
            animation: blinker 1.5s linear infinite;
            text-shadow: 0 0 5px #000;
        }
        #boss-cutin {
            position: absolute;
            top: 150px;
            left: 100%;
            z-index: 60;
            opacity: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #boss-cutin.animate {
            animation: boss-cutin-anim 2.5s ease-in-out forwards;
        }
        #boss-cutin img {
            width: 400px;
            height: auto;
            border: 2px solid white;
            box-shadow: 0 0 20px red;
        }
        #spell-card-cutin-name {
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            margin-top: 10px;
        }
        @keyframes boss-cutin-anim {
            0% { left: 100%; opacity: 1; }
            20% { left: 50%; transform: translateX(-50%); opacity: 1; }
            80% { left: 50%; transform: translateX(-50%); opacity: 1; }
            100% { left: -100%; opacity: 0; }
        }

        /* ã‚¹ãƒãƒ›å‘ã‘ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 850px) {
            #game-container {
                flex-direction: column;
                width: 100vw;
                height: 100vh;
                border: none;
                box-shadow: none;
            }
            #game-canvas-wrapper {
                width: 100%;
                flex-grow: 1;
                min-height: 0;
            }
            #game-canvas {
                width: 100%;
                height: 100%;
            }
            #sidebar {
                width: 100%;
                height: auto;
                flex-shrink: 0;
                border-left: none;
                border-top: 2px solid #fff;
                flex-direction: row; /* æ¨ªä¸¦ã³ã«å¤‰æ›´ */
                flex-wrap: wrap; /* æŠ˜ã‚Šè¿”ã—ã‚’è¨±å¯ */
                justify-content: space-around; /* ã‚¹ãƒšãƒ¼ã‚¹ã‚’å‡ç­‰ã«é…ç½® */
                align-items: center;
                padding: 5px;
            }
            #sidebar > div:first-child {
                display: contents; /* å­è¦ç´ ã‚’grid/flexã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦æ‰±ã† */
            }
            #sidebar h2 {
                width: 100%; /* ã‚¿ã‚¤ãƒˆãƒ«ã¯å…¨å¹… */
                text-align: center;
                margin-bottom: 5px;
                font-size: 16px;
            }
            #sidebar .info {
                font-size: 12px;
                margin-bottom: 2px;
                flex-basis: 45%; /* å„æƒ…å ±é …ç›®ã®åŸºæœ¬å¹… */
            }
            #sidebar .info-label {
                margin-right: 0.5em;
            }
            #boss-health-bar-container {
                height: 15px;
            }
            #dialogue-box {
                height: 120px;
                bottom: 10px;
                left: 5%;
                width: 90%;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="game-canvas-wrapper">
                <div id="start-screen">
                    <img src="https://peutes.github.io/toho_kouhakuma/img/title.png" alt="æ±æ–¹AIç´…ç™½é­”">
                    <p style="margin-top: 20px;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</p>
                    <div class="controls">
                        <div id="pc-controls" style="display: none;">
                            <p><b>æ“ä½œèª¬æ˜(PC)</b></p>
                            <p>ç§»å‹•: åå­—ã‚­ãƒ¼</p>
                            <p>ã‚·ãƒ§ãƒƒãƒˆ: Zã‚­ãƒ¼</p>
                            <p>ãƒœãƒ : Xã‚­ãƒ¼</p>
                            <p>ä½é€Ÿç§»å‹•: Shiftã‚­ãƒ¼</p>
                        </div>
                        <div id="mobile-controls" style="display: none;">
                            <p><b>æ“ä½œèª¬æ˜(SP)</b></p>
                            <p>ç§»å‹•: æŒ‡ã§ãƒ‰ãƒ©ãƒƒã‚°</p>
                            <p>ã‚·ãƒ§ãƒƒãƒˆ: ã‚ªãƒ¼ãƒˆ</p>
                            <p>ãƒœãƒ : ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—</p>
                        </div>
                    </div>
                </div>
                <div id="message-overlay"></div>
                <div id="boss-info" style="display: none;">
                    <div id="boss-name-container">
                        <h3 id="boss-display-name">BOSS</h3>
                        <span id="boss-spell-lives"></span>
                    </div>
                    <div id="boss-health-bar-container">
                        <div id="boss-health-bar"></div>
                    </div>
                    <p id="spell-card-name"></p>
                </div>
                <div id="boss-cutin"><img src="" alt="Boss Cut-in"><div id="spell-card-cutin-name"></div></div>
                <canvas id="game-canvas" width="600" height="800"></canvas>
                <div id="dialogue-box" style="display: none;"></div>
            </div>
            <div id="sidebar">
                <div>
                    <h2 id="sidebar-title">æ±æ–¹AIç´…ç™½é­”</h2>
                    <div class="info">
                        <span class="info-label">SCORE</span>
                        <span id="score" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">PLAYER</span>
                        <span id="lives" class="info-value"></span>
                    </div>
                     <div class="info">
                        <span class="info-label">POWER</span>
                        <span id="power" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">GRAZE</span>
                        <span id="graze" class="info-value">0</span>
                    </div>
                    <div class="info">
                        <span class="info-label">BOMB</span>
                        <span id="bombs" class="info-value"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="player-images">
        <img id="player-img" src="https://peutes.github.io/toho_kouhakuma/img/nitori.png" alt="ã«ã¨ã‚Š">
    </div>
    <div id="boss-images">
        <img id="reimu-img" src="https://peutes.github.io/toho_kouhakuma/img/reimu.png" alt="éœŠå¤¢">
        <img id="marisa-img" src="https://peutes.github.io/toho_kouhakuma/img/marisa.png" alt="é­”ç†æ²™">
    </div>

    <script>
        window.onload = function() {
            // --- åˆæœŸè¨­å®š ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const livesEl = document.getElementById('lives');
            const powerEl = document.getElementById('power');
            const grazeEl = document.getElementById('graze');
            const bombsEl = document.getElementById('bombs');
            const bossInfoEl = document.getElementById('boss-info');
            const bossHealthBar = document.getElementById('boss-health-bar');
            const spellCardNameEl = document.getElementById('spell-card-name');
            const bossSpellLivesEl = document.getElementById('boss-spell-lives');
            const startScreen = document.getElementById('start-screen');
            const messageOverlay = document.getElementById('message-overlay');
            const dialogueBox = document.getElementById('dialogue-box');
            const bossDisplayName = document.getElementById('boss-display-name');
            const bossCutinEl = document.getElementById('boss-cutin');
            const bossCutinImg = bossCutinEl.querySelector('img');
            const spellCardCutinNameEl = document.getElementById('spell-card-cutin-name');

            let gameStarted = false;
            let gameTime = 0;
            let score = 0;
            const keys = {};
            let currentBossName = '';

            const isMobile = /Mobi|Android/i.test(navigator.userAgent);

            // Show appropriate controls
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
            } else {
                document.getElementById('pc-controls').style.display = 'block';
            }

            // Touch control variables
            let isDragging = false;
            let touchStartX, touchStartY;
            let playerStartX, playerStartY;
            let lastTap = 0;

            // --- éŸ³æ¥½ãƒ»åŠ¹æœéŸ³è¨­å®š ---
            let sfx, music;
            function setupAudio() {
                try {
                    if (typeof Tone === 'undefined') {
                        console.error("Tone.js is not loaded yet.");
                        return false;
                    }
                    sfx = {
                        playerShot: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.08, sustain: 0, release: 0.1 } }).toDestination(),
                        bomb: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 1.5, sustain: 0, release: 1 } }).toDestination(),
                        enemyHit: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination(),
                        playerHit: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination(),
                        powerUp: new Tone.Synth({ oscillator: {type: 'sine'}, envelope: {attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2}}).toDestination(),
                        graze: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                        laser: new Tone.Synth({ oscillator: { type: 'pwm', modulationFrequency: 0.2 }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.1, release: 0.2 } }).toDestination(),
                    };
                    Object.values(sfx).forEach(synth => synth.volume.value = -15);
                    sfx.playerHit.volume.value = -5;
                    sfx.graze.volume.value = -20;

                    music = {
                        stage: new Tone.Synth({ oscillator: { type: "fmsquare", harmonicity: 1.2, modulationIndex: 5 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
                        reimu: new Tone.Synth({ oscillator: { type: "fmsquare", modulationType: "sawtooth", harmonicity: 0.8 }, envelope: { attack: 0.02, decay: 0.4, sustain: 0.2, release: 0.2 } }).toDestination(),
                        marisa: new Tone.Synth({ oscillator: { type: "sawtooth", detune: 12 }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.1 } }).toDestination(),
                        drums: new Tone.MembraneSynth().toDestination(),
                        cymbal: new Tone.MetalSynth({ frequency: 250, envelope: { attack: 0.001, decay: 0.05, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
                        activeSeq: null
                    };
                    Object.values(music).forEach(instrument => {
                        if (instrument instanceof Tone.Synth || instrument instanceof Tone.PolySynth || instrument instanceof Tone.MonoSynth || instrument instanceof Tone.MembraneSynth || instrument instanceof Tone.MetalSynth) {
                            instrument.volume.value = -18;
                        }
                    });
                    music.drums.volume.value = -12;

                    return true;
                } catch (e) {
                    console.error("Error setting up audio:", e);
                    return false;
                }
            }

            function stopMusic() {
                try {
                    if (Tone.Transport.state === 'started') {
                        if (music.activeSeq) music.activeSeq.stop(0);
                        Tone.Transport.stop();
                        Tone.Transport.cancel();
                    }
                } catch(e) { /* do nothing */ }
            }

            function playMusic(theme) {
                try {
                    stopMusic();
                    let melody, synth, bpm;
                    switch(theme) {
                        case 'reimu':
                            melody = ['A4','G4','E4','D4', 'E4','G4','A4','C5', 'B4','A4','G4','E4', 'D4','E4','D4','C4'];
                            synth = music.reimu;
                            bpm = 168;
                            break;
                        case 'marisa':
                            melody = ['C5','E5','G5','C6', 'A5','G5','E5','G5', 'F5','A5','C6','F6', 'E6','D6','C6', null];
                            synth = music.marisa;
                            bpm = 185;
                            break;
                        default: // Stage (Nitori's theme)
                            melody = ['G4', 'A#4', 'C5', 'D5', 'G4', 'D5', 'C5', 'A#4', 'G4', 'A#4', 'C5', 'A#4', 'G4', 'F4', 'G4', null];
                            synth = music.stage;
                            bpm = 175;
                    }

                    music.activeSeq = new Tone.Sequence((time, note) => {
                        if (note) synth.triggerAttackRelease(note, '8n', time);
                    }, melody, '4n').start(0);

                    new Tone.Loop(time => {
                        music.drums.triggerAttackRelease("C2", "8n", time);
                        music.cymbal.triggerAttackRelease("C4", "16n", time + Tone.Time('8n').toSeconds());
                    }, '4n').start(0);

                    Tone.Transport.bpm.value = bpm;
                    Tone.Transport.start();
                } catch (e) { /* do nothing */ }
            }

            // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š (ã«ã¨ã‚Š) ---
            const player = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                width: 48,
                height: 48,
                speed: 5,
                lives: 100,
                power: 0,
                bombs: 3,
                graze: 0,
                hitboxRadius: 5,
                grazeRadius: 30,
                shootCooldown: 0,
                invincible: false,
                invincibleTimer: 0,
                bombing: false,
                bombTimer: 0,
                img: document.getElementById('player-img'),
                options: [],
            };

            // --- å„ç¨®é…åˆ— ---
            let bullets = [];
            let enemyBullets = [];
            let enemies = [];
            let particles = [];
            let powerUps = [];
            let lasers = [];
            let bombItems = [];

            // --- ãƒœã‚¹è¨­å®š ---
            const boss = {
                x: canvas.width / 2, y: -100, width: 80, height: 80,
                speed: 2, active: false, visible: true, hp: 0, maxHp: 1,
                phase: 0, phaseTimer: 0, phases: [], currentPhaseIndex: -1,
                img: null, targetX: canvas.width / 2, targetY: 150,
                activeCircles: [],
                orbs: [],
            };

            // --- ã‚¹ãƒ†ãƒ¼ã‚¸è¨­å®š ---
            const stage = {
                timeline: [
                    { time: 120, type: 'fairy', side: 'left', count: 10 },
                    { time: 240, type: 'fairy', side: 'right', count: 10 },
                    { time: 360, type: 'sunflower', side: 'center', count: 2 },
                    { time: 540, type: 'fairy', side: 'v-shape', count: 16 },
                    { time: 720, type: 'sunflower', side: 'left', count: 2 },
                    { time: 720, type: 'sunflower', side: 'right', count: 2 },
                    { time: 900, type: 'boss', name: 'reimu' }
                ],
                nextEventIndex: 0,
                bossQueue: ['marisa']
            };

            // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
            window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            startScreen.addEventListener('click', () => {
                if (!gameStarted) {
                    Tone.start().then(() => {
                        if (!setupAudio()) console.error("åŠ¹æœéŸ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                        gameStarted = true;
                        startScreen.style.display = 'none';
                        resetGame();
                        gameLoop();
                    }).catch(error => {
                        console.error("Tone.js could not be started:", error);
                        gameStarted = true;
                        startScreen.style.display = 'none';
                        resetGame();
                        gameLoop();
                    });
                }
            });

            // --- ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ ---
            function resetGame() {
                gameTime = 0; score = 0;
                player.lives = 100;
                player.power = 0; player.graze = 0; player.bombs = 3;
                player.x = canvas.width / 2; player.y = canvas.height - 100;
                bullets = []; enemyBullets = []; enemies = []; particles = []; powerUps = []; lasers = []; bombItems = [];
                boss.active = false;
                stage.nextEventIndex = 0;
                stage.bossQueue = ['marisa'];
                updatePlayerOptions();
                playMusic('stage');
                updateUI();
            }

            // --- æç”»é–¢æ•° ---
            function drawPlayer() {
                if (player.invincible && Math.floor(player.invincibleTimer / 6) % 2 === 0) return;
                ctx.drawImage(player.img, player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);

                // Draw hitbox
                if (keys['shift'] || (isMobile && isDragging)) { // ã‚¹ãƒãƒ›ã§ã‚‚ä½é€Ÿç§»å‹•ï¼ˆå½“ãŸã‚Šåˆ¤å®šè¡¨ç¤ºï¼‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.hitboxRadius + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw options
                player.options.forEach(opt => {
                    const x = player.x + opt.x;
                    const y = player.y + opt.y;
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            function drawBullets() {
                bullets.forEach(b => {
                    ctx.fillStyle = b.color;
                    ctx.shadowColor = b.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            function drawEnemyBullets() {
                enemyBullets.forEach(b => {
                    ctx.save();
                    ctx.globalAlpha = b.alpha || 1.0;
                    ctx.translate(b.x, b.y);
                    ctx.rotate(b.angle);
                    ctx.shadowColor = b.color;
                    ctx.shadowBlur = 8;
                    if (b.shape === 'amulet') {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-b.radius * 0.5, -b.radius, b.radius, b.radius * 2);
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-b.radius * 0.15, -b.radius * 0.7, b.radius * 0.3, b.radius * 1.4);
                    } else if (b.shape === 'star') {
                        ctx.fillStyle = b.color;
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * b.radius, -Math.sin((18 + i * 72) * Math.PI / 180) * b.radius);
                            ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * b.radius * 0.5, -Math.sin((54 + i * 72) * Math.PI / 180) * b.radius * 0.5);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillStyle = b.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                });
                ctx.shadowBlur = 0;
            }

            function drawEnemies() {
                enemies.forEach(e => {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.angle);
                    ctx.fillStyle = e.color;
                    ctx.fillRect(-e.width / 2, -e.height / 2, e.width, e.height);
                    ctx.restore();
                });
            }

            function drawPowerUps() {
                powerUps.forEach(p => {
                    ctx.fillStyle = '#ff5555';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px DotGothic16';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('P', p.x, p.y);
                });
            }

            function drawBombItems() {
                bombItems.forEach(b => {
                    ctx.fillStyle = '#8888ff';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px DotGothic16';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('B', b.x, b.y);
                });
            }

            function drawBoss() {
                if (!boss.active || !boss.visible || !boss.img) return;
                ctx.drawImage(boss.img, boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
            }

            function drawLasers() {
                lasers.forEach(l => {
                    ctx.save();
                    ctx.translate(l.x, l.y);
                    ctx.rotate(l.angle);
                    ctx.globalAlpha = l.alpha;
                    if (l.width > 20) {
                        const grad = ctx.createLinearGradient(0, -l.width / 2, 0, l.width / 2);
                        const baseColor = l.color.replace('rgb(', '').replace(')', '');
                        grad.addColorStop(0, `rgba(${baseColor}, 0)`);
                        grad.addColorStop(0.2, `rgba(${baseColor}, 0.8)`);
                        grad.addColorStop(0.5, `rgba(${baseColor}, 1)`);
                        grad.addColorStop(0.8, `rgba(${baseColor}, 0.8)`);
                        grad.addColorStop(1, `rgba(${baseColor}, 0)`);
                        ctx.fillStyle = grad;
                    } else {
                        ctx.fillStyle = l.color;
                    }
                    ctx.fillRect(0, -l.width / 2, canvas.height * 1.5, l.width);
                    ctx.restore();
                });
            }

            function drawParticles() {
                particles.forEach(p => {
                    ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawPlayerBomb() {
                if (!player.bombing) return;
                const t = player.bombTimer / 120;
                const radius = Math.sin(Math.PI * t) * canvas.width;

                const grad = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, radius);
                grad.addColorStop(0, 'rgba(200, 255, 255, 0.8)');
                grad.addColorStop(0.5, 'rgba(60, 179, 113, 0.6)');
                grad.addColorStop(1, 'rgba(30, 144, 255, 0.2)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            function updateUI() {
                scoreEl.textContent = score;
                livesEl.textContent = 'x ' + player.lives;
                powerEl.textContent = player.power;
                grazeEl.textContent = player.graze;
                bombsEl.innerHTML = `&#x1F9A0; x ${player.bombs}`;

                if (boss.active) {
                    bossInfoEl.style.display = 'block';
                    const healthPercentage = Math.max(0, boss.hp / boss.maxHp);
                    bossHealthBar.style.width = `${healthPercentage * 100}%`;

                    if (currentBossName === 'reimu') {
                        bossDisplayName.innerHTML = 'BOSS â›©ï¸';
                    } else if (currentBossName === 'marisa') {
                        bossDisplayName.innerHTML = 'BOSS ğŸ§™';
                    }

                    const remainingSpells = boss.phases.filter((p, i) => p.type === 'spell' && i >= boss.currentPhaseIndex).length;
                    bossSpellLivesEl.innerHTML = '&#x2605;'.repeat(remainingSpells);

                } else {
                    bossInfoEl.style.display = 'none';
                    spellCardNameEl.textContent = '';
                }
            }

            // --- æ›´æ–°é–¢æ•° ---
            function updatePlayer() {
                // Keyboard movement
                if (!isMobile) {
                    if (keys['shift']) {
                        player.speed = 2.5;
                    } else {
                        player.speed = 5;
                    }
                    if (keys['arrowleft'] && player.x > player.width / 2) player.x -= player.speed;
                    if (keys['arrowright'] && player.x < canvas.width - player.width / 2) player.x += player.speed;
                    if (keys['arrowup'] && player.y > player.height / 2) player.y -= player.speed;
                    if (keys['arrowdown'] && player.y < canvas.height - player.height / 2) player.y += player.speed;
                }

                // Auto-fire logic
                if (keys['z'] || (isMobile && isDragging)) {
                    fireShot();
                }
                if (player.shootCooldown > 0) player.shootCooldown--;

                // Keyboard bomb
                if (keys['x']) {
                    fireBomb();
                    keys['x'] = false; // Prevent holding down
                }

                if (player.bombing) {
                    if(player.bombTimer % 10 === 0) {
                         if (boss.active && !boss.invincible) {
                             boss.hp -= 268; // â˜…å¤‰æ›´: ãƒœãƒ ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’2å€ã«
                         }
                         enemies.forEach(e => e.hp -= 132); // â˜…å¤‰æ›´: ãƒœãƒ ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’2å€ã«
                    }
                    player.bombTimer--;
                    if (player.bombTimer <= 0) player.bombing = false;
                }

                if (player.invincible) {
                    player.invincibleTimer--;
                    if (player.invincibleTimer <= 0) player.invincible = false;
                }
            }

            function fireShot() {
                if (player.shootCooldown > 0) return;
                try { if(sfx) sfx.playerShot.triggerAttackRelease('A4', '8n'); } catch(e) {}
                player.shootCooldown = 5;
                const speed = 18;

                // Nitori's main shot
                const shotLevel = Math.floor(player.power / 10);
                const shotCount = Math.min(5, 1 + shotLevel);

                if (shotCount === 1) {
                    bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                } else if (shotCount === 2) {
                    bullets.push({ x: player.x - 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 8, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                } else if (shotCount === 3) {
                    bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x - 15, y: player.y, dx: -0.1 * speed, dy: -0.95 * speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 15, y: player.y, dx: 0.1 * speed, dy: -0.95 * speed, radius: 5, color: '#32cd32', damage: 15 });
                } else if (shotCount === 4) {
                    bullets.push({ x: player.x - 8, y: player.y, dx: -0.05 * speed, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 8, y: player.y, dx: 0.05 * speed, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x - 20, y: player.y, dx: -0.15 * speed, dy: -0.9 * speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 20, y: player.y, dx: 0.15 * speed, dy: -0.9 * speed, radius: 5, color: '#32cd32', damage: 15 });
                } else if (shotCount >= 5) {
                    bullets.push({ x: player.x, y: player.y, dx: 0, dy: -speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x - 15, y: player.y, dx: -0.1 * speed, dy: -0.95 * speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 15, y: player.y, dx: 0.1 * speed, dy: -0.95 * speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x - 30, y: player.y, dx: -0.2 * speed, dy: -0.9 * speed, radius: 5, color: '#32cd32', damage: 15 });
                    bullets.push({ x: player.x + 30, y: player.y, dx: 0.2 * speed, dy: -0.9 * speed, radius: 5, color: '#32cd32', damage: 15 });
                }

                // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ãƒŸã‚µã‚¤ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯ â˜…â˜…â˜…
                player.options.forEach(opt => {
                    const startX = player.x + opt.x;
                    const startY = player.y + opt.y;

                    const missile = {
                        x: startX,
                        y: startY,
                        radius: 6,
                        color: '#87ceeb',
                        damage: 25,
                        speed: 8,
                        angle: -Math.PI / 2, // Start by moving straight up
                        turnRate: 0.05, // How fast it can turn (radians per frame)
                        target: null,
                        life: 300, // 5ç§’ã®å¯¿å‘½ (60fps * 5)
                        lockedOn: false, // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒ­ãƒƒã‚¯ã‚ªãƒ³ã—ãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

                        // å¼¾ã”ã¨ã®ç‰¹åˆ¥ãªæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
                        update: function() {
                            this.life--;
                            if (this.life <= 0) {
                                const index = bullets.indexOf(this);
                                if (index > -1) bullets.splice(index, 1);
                                return;
                            }

                            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒãƒ­ãƒƒã‚¯ã‚ªãƒ³ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¢ã—ç¶šã‘ã‚‹
                            if (!this.lockedOn) {
                                if (!this.target || this.target.hp <= 0) {
                                    this.target = findClosestEnemy(this.x, this.y);
                                }
                            }

                            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã„ã‚‹å ´åˆã€ãã¡ã‚‰ã¸å‘ã‹ã†
                            if (this.target) {
                                const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                                let angleDiff = targetAngle - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ååˆ†è¿‘ã„å ´åˆã€è§’åº¦ã‚’ãƒ­ãƒƒã‚¯ã—ã¦ç›´é€²ã™ã‚‹
                                const dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                                if (!this.lockedOn && dist < 100 && Math.abs(angleDiff) < 0.2) {
                                     this.lockedOn = true;
                                }

                                // ãƒ­ãƒƒã‚¯ã‚ªãƒ³ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€æ—‹å›ã™ã‚‹
                                if (!this.lockedOn) {
                                    if (Math.abs(angleDiff) > this.turnRate) {
                                        this.angle += this.turnRate * Math.sign(angleDiff);
                                    } else {
                                        this.angle = targetAngle;
                                    }
                                }
                            }

                            // è¨ˆç®—ã•ã‚ŒãŸè§’åº¦ã«åŸºã¥ã„ã¦ç§»å‹•
                            this.dx = Math.cos(this.angle) * this.speed;
                            this.dy = Math.sin(this.angle) * this.speed;
                            this.x += this.dx;
                            this.y += this.dy;
                        }
                    };
                    bullets.push(missile);
                });
                 // â˜…â˜…â˜… ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ãƒŸã‚µã‚¤ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§ â˜…â˜…â˜…
            }

            function fireBomb() {
                if (player.bombs > 0 && !player.bombing) {
                    try { if(sfx) sfx.bomb.triggerAttackRelease("2n"); } catch(e) {}
                    player.bombs--;
                    player.bombing = true;
                    player.bombTimer = 120;
                    player.invincible = true;
                    player.invincibleTimer = 150;

                    // ãƒœãƒ ç™ºå‹•æ™‚ã«æ•µå¼¾ã‚’æ¶ˆå»
                    enemyBullets = [];
                    lasers = []; //ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚‚æ¶ˆã™
                }
            }

            function updateBullets() {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    if (!b) continue; // å®‰å…¨ç­–
                    if (b.update) {
                        b.update(); // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ãƒŸã‚µã‚¤ãƒ«ãªã©ã®ç‰¹æ®Šãªæ›´æ–°
                    } else {
                        b.x += b.dx;
                        b.y += b.dy;
                    }
                    if (b.y < -b.radius || b.x < -b.radius || b.x > canvas.width + b.radius || b.y > canvas.height + b.radius) {
                        bullets.splice(i, 1);
                    }
                }
            }

            function updatePowerUps() {
                powerUps.forEach((p, i) => {
                    const dist = Math.hypot(p.x - player.x, p.y - player.y);
                    // ç”»é¢ä¸Šéƒ¨ã§ã®è‡ªå‹•å›å
                    const autoCollect = player.y < 150;

                    if (dist < player.hitboxRadius + p.radius) {
                        if (player.power < 40) {
                           player.power += 10;
                           updatePlayerOptions();
                        } else {
                           score += 1000;
                        }
                        try { if(sfx) sfx.powerUp.triggerAttackRelease('G5', '8n'); } catch(e) {}
                        powerUps.splice(i, 1);
                    } else {
                        const dy = player.y - p.y;
                        const dx = player.x - p.x;
                        if (dist < 80 || autoCollect) {
                            p.x += dx / dist * 6;
                            p.y += dy / dist * 6;
                        } else {
                             p.y += p.speed;
                        }
                        if (p.y > canvas.height + p.radius) powerUps.splice(i, 1);
                    }
                });
            }

            function updateBombItems() {
                bombItems.forEach((b, i) => {
                     const dist = Math.hypot(b.x - player.x, b.y - player.y);
                     const autoCollect = player.y < 150;

                    if (dist < player.hitboxRadius + b.radius) {
                        if (player.bombs < 8) player.bombs++;
                        try { if(sfx) sfx.powerUp.triggerAttackRelease('A5', '8n'); } catch(e) {}
                        bombItems.splice(i, 1);
                    } else {
                        const dy = player.y - b.y;
                        const dx = player.x - b.x;
                        if (dist < 80 || autoCollect) {
                            b.x += dx / dist * 6;
                            b.y += dy / dist * 6;
                        } else {
                            b.y += b.speed;
                        }
                        if (b.y > canvas.height + b.radius) bombItems.splice(i, 1);
                    }
                });
            }

            function updateEnemyBullets() {
                enemyBullets.forEach((b, i) => {
                    try {
                        if (b.update) b.update();
                        else { b.x += b.dx; b.y += b.dy; }
                        if (b.x < -b.radius - 20 || b.x > canvas.width + b.radius + 20 || b.y < -b.radius - 20 || b.y > canvas.height + b.radius + 20) {
                            enemyBullets.splice(i, 1);
                        }
                    } catch(e) {
                        enemyBullets.splice(i, 1);
                    }
                });
            }

            function updateLasers() {
                lasers.forEach((l, i) => {
                    try {
                        if(l.update) l.update();
                        l.timer--;
                        if (l.timer < 30) l.alpha = l.timer / 30;
                        if (l.timer <= 0) lasers.splice(i, 1);
                    } catch (e) {
                         lasers.splice(i, 1);
                    }
                });
            }

            function updateEnemies() {
                enemies.forEach((e, i) => {
                    try {
                        e.update();
                        if (e.hp <= 0) {
                            try { if(sfx) sfx.enemyHit.triggerAttackRelease('C2', '8n'); } catch(err) {}
                            score += e.score;
                            if (Math.random() < 0.3) spawnPowerUp(e.x, e.y);
                            if (Math.random() < 0.05) spawnBombItem(e.x, e.y);
                            createExplosion(e.x, e.y, e.color, 20);
                            enemies.splice(i, 1);
                        } else if (e.y > canvas.height + e.height) {
                            enemies.splice(i, 1);
                        }
                    } catch (err) {
                        enemies.splice(i, 1);
                    }
                });
            }

            function updateBoss() {
                if (!boss.active) return;
                if (boss.phase === -1) return;

                if (boss.phase === 0) {
                    boss.y += boss.speed;
                    if (boss.y >= 150) {
                        boss.phase = -1;
                        handleBossDialogue(currentBossName);
                    }
                    return;
                }

                if (boss.currentPhaseIndex >= boss.phases.length) return;

                const dx = boss.targetX - boss.x, dy = boss.targetY - boss.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 1) { boss.x += dx / dist * boss.speed; boss.y += dy / dist * boss.speed; }

                boss.phaseTimer++;
                const currentPhase = boss.phases[boss.currentPhaseIndex];
                if (!currentPhase) return;

                let phaseOver = false;
                if (currentPhase.type === 'spell') {
                    if (boss.hp <= 0 || boss.phaseTimer > currentPhase.card.duration) {
                        if (boss.hp <= 0) {
                            score += 50000;
                            for(let i = 0; i < 15; i++) spawnPowerUp(boss.x + (Math.random() - 0.5) * 100, boss.y + (Math.random() - 0.5) * 100);
                            for(let i = 0; i < 3; i++) spawnBombItem(boss.x + (Math.random() - 0.5) * 100, boss.y + (Math.random() - 0.5) * 100);
                        }
                        phaseOver = true;
                    }
                    currentPhase.card.func();
                } else { // non-spell
                    if (boss.hp <= 0 || boss.phaseTimer > currentPhase.duration) phaseOver = true;
                    currentPhase.func();
                }

                if (phaseOver) startNextBossPhase();
            }

            function updateParticles() {
                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
                    if (p.alpha <= 0) particles.splice(i, 1);
                });
            }

            function updateStage() {
                if (boss.active) return;
                if (stage.nextEventIndex < stage.timeline.length) {
                    const event = stage.timeline[stage.nextEventIndex];
                    if (gameTime >= event.time) {
                        if (event.type === 'boss') {
                            spawnBoss(event.name);
                        } else {
                            spawnEnemies(event);
                        }
                        stage.nextEventIndex++;
                    }
                }
            }

            // --- è¡çªåˆ¤å®š ---
            function checkCollisions() {
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const b = bullets[bi];
                    if (!b) continue;

                    let hit = false;
                    for (let ei = enemies.length - 1; ei >= 0; ei--) {
                        const e = enemies[ei];
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.width / 2 + b.radius) {
                            e.hp -= b.damage || 10;
                            hit = true;
                            break;
                        }
                    }

                    if (hit) {
                        bullets.splice(bi, 1);
                        try { if(sfx) sfx.enemyHit.triggerAttackRelease('C3', '8n'); } catch(err) {}
                        createExplosion(b.x, b.y, '#ffffff', 5);
                        continue;
                    }

                    if (boss.active && !boss.invincible && boss.visible && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.width / 2 + b.radius) {
                        boss.hp -= b.damage || 10;
                        bullets.splice(bi, 1);
                        try { if(sfx) sfx.enemyHit.triggerAttackRelease('C3', '8n'); } catch(e) {}
                        createExplosion(b.x, b.y, '#ffffff', 5);
                    }
                }

                if (player.invincible) return;

                enemyBullets.forEach(b => {
                    if (!b.grazed && Math.hypot(b.x - player.x, b.y - player.y) < player.grazeRadius) {
                        b.grazed = true; player.graze++; score += 100;
                        try { if(sfx) sfx.graze.triggerAttackRelease("C7", "32n"); } catch(e) {}
                    }
                    if (!b.isWarning && Math.hypot(b.x - player.x, b.y - player.y) < player.hitboxRadius + b.radius) playerHit();
                });

                lasers.forEach(l => {
                    const playerDist = Math.abs((l.x - player.x) * Math.sin(l.angle) - (l.y - player.y) * Math.cos(l.angle));
                    if (l.alpha > 0.5 && playerDist < l.width / 2 + player.hitboxRadius) playerHit();
                });
            }

            function playerHit() {
                if (player.invincible) return;
                try { if(sfx) sfx.playerHit.triggerAttackRelease("16n"); } catch(e) {}
                player.lives--;
                updatePlayerOptions();

                createExplosion(player.x, player.y, '#ff0000', 50);
                if (player.lives < 0) {
                    gameOver();
                } else {
                    player.invincible = true;
                    player.invincibleTimer = 180;
                    player.x = canvas.width / 2;
                    player.y = canvas.height - 100;
                }
            }

            function spawnPowerUp(x, y) {
                powerUps.push({ x, y, speed: 1.5, radius: 10 });
            }

            function spawnBombItem(x, y) {
                bombItems.push({ x, y, speed: 1.5, radius: 10 });
            }

            function spawnEnemies(event) {
                for (let i = 0; i < event.count; i++) {
                    let enemy;
                    const commonProps = {
                        hp: 30,
                        score: 200,
                        shootCooldown: 45 + Math.random() * 30,
                        shootTimer: 0,
                    };
                    if (event.type === 'fairy') {
                        enemy = { ...commonProps, x: 0, y: 0, width: 25, height: 25, color: '#90ee90', angle: 0, moveType: event.side, moveTimer: i * 15,
                            update() {
                                this.moveTimer++;
                                if (this.moveType === 'left') { this.x = 50 + Math.sin(this.moveTimer / 50) * 30; this.y += 2.5; }
                                else if (this.moveType === 'right') { this.x = canvas.width - 50 - Math.sin(this.moveTimer / 50) * 30; this.y += 2.5; }
                                else if (this.moveType === 'v-shape') { const side = i % 2 === 0 ? 1 : -1; this.x = canvas.width / 2 + side * this.moveTimer * 2.5; this.y = 100 + this.moveTimer * 2.5; }
                                else { this.x = (canvas.width / (event.count + 1)) * (i + 1); this.y = -30 - i * 20; this.y += 2.5; }
                                this.shootTimer++;
                                if (this.shootTimer > this.shootCooldown) {
                                    this.shootTimer = 0;
                                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                                    createEnemyBullet(this.x, this.y, 4, angle, '#ff8888', 5);
                                }
                            }
                        };
                    } else if (event.type === 'sunflower') {
                        enemy = { ...commonProps, hp: 100, score: 500, x: event.side === 'left' ? 150 : (event.side === 'right' ? 450 : 300), y: -30 - i * 40, width: 40, height: 40, color: '#ffcc00', angle: 0, moveTimer: 0,
                            update() {
                                if (this.y < 150 + i * 20) this.y += 2;
                                this.angle += 0.03;
                                this.shootTimer++;
                                if (this.shootTimer > this.shootCooldown) {
                                    this.shootTimer = 0;
                                    for (let j = 0; j < 12; j++) {
                                        const angle = (Math.PI * 2 / 12) * j + this.moveTimer / 20;
                                        createEnemyBullet(this.x, this.y, 3, angle, '#ffff00', 6);
                                    }
                                }
                                this.moveTimer++;
                            }
                        };
                    }
                    if (enemy) enemies.push(enemy);
                }
            }

            // --- ãƒœã‚¹ã®è¡Œå‹• ---
            function spawnBoss(name) {
                currentBossName = name;
                boss.active = true;
                boss.y = -100;
                boss.x = canvas.width / 2;
                boss.phase = 0;
                boss.currentPhaseIndex = -1;
                playMusic(name);
                enemies = []; // ãƒœã‚¹æˆ¦é–‹å§‹æ™‚ã«ã‚¶ã‚³æ•µã‚’æ¶ˆå»

                if (name === 'reimu') {
                    boss.img = document.getElementById('reimu-img');
                    boss.phases = [
                        { type: 'spell', hp: 15000, card: { name: 'å¤¢ç¬¦ã€ŒäºŒé‡çµç•Œã€', duration: 1500, func: duplexBarrier } },
                        { type: 'spell', hp: 15000, card: { name: 'ãŠæœ­ã€Œæ–°èæ‹¡å¼µå›£èª¿ä¼ã€', duration: 1500, func: newspaperSubjugation } },
                        { type: 'spell', hp: 15000, card: { name: 'éœŠç¬¦ã€Œå¤¢æƒ³å°å° é›†ã€', duration: 1500, func: fantasySealClump } },
                        { type: 'spell', hp: 15000, card: { name: 'çµç•Œã€Œãƒ‘ãƒ‘ãƒ©ãƒƒãƒæ’ƒé€€çµç•Œã€', duration: 1500, func: paparazziBoundary } },
                        { type: 'spell', hp: 15000, card: { name: 'å¤¢ç¬¦ã€Œå°é­”é™£ã€', duration: 1500, func: evilSealingCircle } },
                        { type: 'spell', hp: 15000, card: { name: 'ç¥åŸŸã€Œç¥éœŠå¤§çµç•Œã€', duration: 1500, func: greatDivineBarrier } },
                        { type: 'spell', hp: 15000, card: { name: 'å¢ƒç•Œã€ŒäºŒé‡å¼¾å¹•çµç•Œã€', duration: 1500, func: duplexDanmakuBarrier } },
                        { type: 'spell', hp: 15000, card: { name: 'éœŠç¬¦ã€Œå¤¢æƒ³å¦™ç ã€', duration: 1500, func: fantasySeal } },
                    ];
                } else if (name === 'marisa') {
                    boss.img = document.getElementById('marisa-img');
                    boss.phases = [
                        { type: 'spell', hp: 15000, card: { name: 'é­”ç¬¦ã€ŒãƒŸãƒ«ã‚­ãƒ¼ã‚¦ã‚§ã‚¤ã€', duration: 1500, func: milkyWay } },
                        { type: 'spell', hp: 15000, card: { name: 'é­”ç¬¦ã€Œã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆãƒ¬ãƒ´ã‚¡ãƒªã‚¨ã€', duration: 1500, func: stardustReverie } },
                        { type: 'spell', hp: 15000, card: { name: 'æ‹ç¬¦ã€Œãƒãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒŠãƒ«ãƒ¬ãƒ¼ã‚¶ãƒ¼ã€', duration: 1500, func: nonDirectionalLaser } },
                        { type: 'spell', hp: 15000, card: { name: 'æ‹ç¬¦ã€Œãƒã‚¹ã‚¿ãƒ¼ã‚¹ãƒ‘ãƒ¼ã‚¯ã€', duration: 1500, func: masterSpark } },
                        { type: 'spell', hp: 15000, card: { name: 'å…‰ç¬¦ã€Œã‚¢ãƒ¼ã‚¹ãƒ©ã‚¤ãƒˆãƒ¬ã‚¤ã€', duration: 1500, func: earthlightRay } },
                        { type: 'spell', hp: 15000, card: { name: 'é­”ç ²ã€Œãƒ•ã‚¡ã‚¤ãƒŠãƒ«ã‚¹ãƒ‘ãƒ¼ã‚¯ã€', duration: 1500, func: finalSpark } },
                        { type: 'spell', hp: 15000, card: { name: 'æ˜Ÿç¬¦ã€Œãƒ¡ãƒ†ã‚ªãƒ‹ãƒƒã‚¯ã‚·ãƒ£ãƒ¯ãƒ¼ã€', duration: 1500, func: meteonicShower } },
                        { type: 'spell', hp: 15000, card: { name: 'å…‰ç¬¦ã€Œã‚¢ã‚¹ãƒ†ãƒ­ã‚¤ãƒ‰ãƒ™ãƒ«ãƒˆã€', duration: 1500, func: asteroidBelt } },
                        { type: 'spell', hp: 15000, card: { name: 'å½—æ˜Ÿã€Œãƒ–ãƒ¬ã‚¤ã‚¸ãƒ³ã‚°ã‚¹ã‚¿ãƒ¼ã€', duration: 1500, func: blazingStar } },
                    ];
                }
            }

            function handleBossDialogue(name) {
                const bossNameJP = name === 'reimu' ? 'åšéº—éœŠå¤¢' : 'éœ§é›¨é­”ç†æ²™';
                showOverlayMessage(`${bossNameJP}ãŒç¾ã‚ŒãŸ...`, 180); // 3ç§’è¡¨ç¤º

                setTimeout(() => {
                    let defaultDialogue;
                    if (name === 'reimu') {
                        defaultDialogue = '<p><strong>éœŠå¤¢:</strong> ã¡ã‚‡ã£ã¨ã€ã‚ãªãŸã€‚ç¥ç¤¾ã®è£ã§å¤‰ãªæ©Ÿæ¢°ã‚’å‹•ã‹ã™ã®ã¯ã‚„ã‚ã¦ã¡ã‚‡ã†ã ã„ã€‚</p><p><strong>ã«ã¨ã‚Š:</strong> ã²ã‚ƒã£ï¼ï¼Ÿã¿ã€è¦‹ã¤ã‹ã£ãŸï¼ã“ã‚Œã¯ãŸã ã®å®Ÿé¨“ã§â€¦ã‚ã€ã‚ãªãŸã«ã¯æ¸¡ã•ãªã„ã‚“ã ã‹ã‚‰ï¼</p>';
                    } else {
                        defaultDialogue = '<p><strong>é­”ç†æ²™:</strong> ãŠã€ãªã‚“ã ãã®ã‚¬ãƒ©ã‚¯ã‚¿ï¼Ÿé¢ç™½ãã†ã˜ã‚ƒãªã„ã‹ï¼ã¡ã‚‡ã£ã¨è¦‹ã›ã¦ã‚‚ã‚‰ã†ãœï¼</p><p><strong>ã«ã¨ã‚Š:</strong> ã“ã€ã“ã‚Œã¯ç§ã®æœ€é«˜å‚‘ä½œãªã‚“ã ã‹ã‚‰ï¼å‹æ‰‹ã«è§¦ã‚‰ãªã„ã§ã‚ˆï¼</p>';
                    }

                    dialogueBox.style.display = 'block';
                    dialogueBox.innerHTML = `<div>${defaultDialogue}</div><div class="continue-prompt">â–¼ ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç¶šè¡Œ</div>`;

                    const continueFight = () => {
                        dialogueBox.style.display = 'none';
                        startNextBossPhase();
                        boss.phase = 1;
                        dialogueBox.removeEventListener('click', continueFight);
                    };
                    dialogueBox.addEventListener('click', continueFight, { once: true });
                }, 3000);
            }

            function startNextBossPhase() {
                boss.currentPhaseIndex++;
                if (boss.currentPhaseIndex >= boss.phases.length) {
                    bossDefeated();
                    return;
                }
                const currentPhase = boss.phases[boss.currentPhaseIndex];
                boss.hp = currentPhase.hp;
                boss.maxHp = currentPhase.hp;
                boss.phaseTimer = 0;
                boss.invincible = true;
                boss.visible = true;
                boss.activeCircles = [];
                boss.orbs = [];
                enemyBullets = []; lasers = [];
                setTimeout(() => { boss.invincible = false; }, 1500);

                if (currentPhase.type === 'spell') {
                    spellCardNameEl.textContent = currentPhase.card.name;
                    spellCardCutinNameEl.textContent = currentPhase.card.name;
                    bossCutinImg.src = boss.img.src;
                    bossCutinEl.classList.add('animate');
                    setTimeout(() => {
                        bossCutinEl.classList.remove('animate');
                    }, 2500);
                } else {
                    spellCardNameEl.textContent = '';
                }
                boss.targetX = Math.random() * (canvas.width - 200) + 100;
                boss.targetY = Math.random() * 100 + 100;
            }

            function bossDefeated() {
                createExplosion(boss.x, boss.y, '#00ffff', 200, 5000);
                score += 100000;
                boss.active = false;

                if (stage.bossQueue.length > 0) {
                    const nextBoss = stage.bossQueue.shift();
                    showOverlayMessage("WARNING!", 120);
                    setTimeout(() => spawnBoss(nextBoss), 2000);
                } else {
                    showOverlayMessage("ALL CLEAR!", 300);
                    stopMusic();
                    setTimeout(() => {
                         gameStarted = false;
                         startScreen.style.display = 'flex';
                    }, 5000);
                }
            }

            // --- Reimu Spell Cards ---
            function duplexBarrier() {
                if (boss.phaseTimer % 45 === 0) {
                    const baseAngle = Math.random() * Math.PI * 2;
                    for (let j = 0; j < 2; j++) {
                        for (let i = 0; i < 20; i++) {
                            const angle = baseAngle + (i * Math.PI * 2 / 20);
                            createEnemyBullet(boss.x, boss.y, 3 + j * 1.5, angle, j === 0 ? '#ffaaaa' : '#aaaaff', 7, 'amulet');
                        }
                    }
                }
            }
            function fantasySeal() {
                if (boss.phaseTimer % 20 === 0) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2 / 8) + boss.phaseTimer * 0.05;
                        const bullet = createEnemyBullet(boss.x, boss.y, 0, angle, '#ff5555', 10, 'amulet');
                        bullet.speed = 2.5;
                        bullet.turnRate = 0.025;
                        bullet.life = 150;
                        bullet.update = function() {
                            this.life--;
                            if (this.life <= 0) {
                                for (let k = 0; k < 8; k++) {
                                    const explosionAngle = (k * Math.PI * 2 / 8);
                                    createEnemyBullet(this.x, this.y, 4, explosionAngle, '#ffaaaa', 4, 'amulet');
                                }
                                const index = enemyBullets.indexOf(this);
                                if (index > -1) enemyBullets.splice(index, 1);
                                return;
                            }
                            const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                            let angleDiff = targetAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            this.angle += Math.max(-this.turnRate, Math.min(this.turnRate, angleDiff));
                            this.dx = Math.cos(this.angle) * this.speed;
                            this.dy = Math.sin(this.angle) * this.speed;
                            this.x += this.dx;
                            this.y += this.dy;
                        }
                    }
                }
            }

            function evilSealingCircle() {
                if (boss.phaseTimer % 150 === 1) {
                    boss.activeCircles.push({
                        x: player.x, y: player.y, radius: 250, life: 300,
                        spawnCooldown: 0, rotation: Math.random() * Math.PI * 2,
                    });
                }
                for (let i = boss.activeCircles.length - 1; i >= 0; i--) {
                    const circle = boss.activeCircles[i];
                    circle.life--;
                    circle.spawnCooldown--;
                    if (circle.life > 60 && circle.spawnCooldown <= 0) {
                        circle.spawnCooldown = 6;
                        circle.rotation += 0.06;
                        for (let j = 0; j < 10; j++) {
                            const angle = circle.rotation + (j * Math.PI * 2 / 10);
                            const sx = circle.x + Math.cos(angle) * circle.radius;
                            const sy = circle.y + Math.sin(angle) * circle.radius;
                            const bulletAngle = angle + Math.PI;
                            createEnemyBullet(sx, sy, 3, bulletAngle, '#aaaaff', 6, 'amulet');
                        }
                    }
                    ctx.save();
                    ctx.globalAlpha = Math.min(1, (300 - circle.life) / 60) * Math.min(1, circle.life / 60);
                    ctx.strokeStyle = '#ff8888';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    if (circle.life <= 0) {
                        boss.activeCircles.splice(i, 1);
                    }
                }
            }

            function greatDivineBarrier() {
                if (boss.phaseTimer === 1) {
                    boss.orbs = [];
                    for (let i = 0; i < 3; i++) {
                        boss.orbs.push({
                            angle: i * Math.PI * 2 / 3, radius: 250, shootCooldown: 0, rotation: 0,
                        });
                    }
                }
                if (boss.orbs) {
                    boss.orbs.forEach(orb => {
                        orb.angle += 0.008;
                        const orbX = canvas.width / 2 + Math.cos(orb.angle) * orb.radius;
                        const orbY = 200 + Math.sin(orb.angle) * orb.radius;
                        orb.rotation += 0.1;
                        ctx.save();
                        ctx.translate(orbX, orbY);
                        ctx.rotate(orb.rotation);
                        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -10, 10, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 10, 10, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 10, 4, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -10, 4, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();

                        orb.shootCooldown--;
                        if (orb.shootCooldown <= 0) {
                            orb.shootCooldown = 15;
                            const angleToPlayer = Math.atan2(player.y - orbY, player.x - orbX);
                            for (let i = -1; i <= 1; i++) {
                                createEnemyBullet(orbX, orbY, 4, angleToPlayer + i * 0.15, '#ff8888', 6, 'amulet');
                            }
                        }
                    });
                }
                if (boss.phaseTimer % 25 === 0) {
                    const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + (Math.random() - 0.5) * 0.2;
                    createEnemyBullet(boss.x, boss.y, 5, angle, '#ff5555', 8, 'amulet');
                }
            }

            function newspaperSubjugation() {
                if (boss.phaseTimer % 15 === 0) {
                    const x = Math.random() * canvas.width;
                    const bullet = createEnemyBullet(x, 0, 1.5, Math.PI / 2, '#ffffff', 8, 'amulet');
                    bullet.life = 90 + Math.random() * 40;
                    bullet.update = function() {
                        this.life--;
                        if (this.life <= 0) {
                            const angle = Math.atan2(player.y - this.y, player.x - this.x);
                            this.dx = Math.cos(angle) * 7;
                            this.dy = Math.sin(angle) * 7;
                            this.update = undefined;
                        }
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }

            function paparazziBoundary() {
                if (boss.phaseTimer % 150 === 1) {
                    const gapSize = 120;
                    const gapY = Math.random() * (canvas.height - gapSize);

                    for (let y = 0; y < canvas.height; y += 20) {
                        if (y > gapY && y < gapY + gapSize) {
                            continue;
                        }
                        createEnemyBullet(0, y, 3, 0, '#ffcccc', 5, 'amulet');
                        createEnemyBullet(canvas.width, y, -3, 0, '#ffcccc', 5, 'amulet');
                    }
                }
                if (boss.phaseTimer % 150 === 75) {
                    const flashWarning = createEnemyBullet(player.x, player.y, 0, 0, 'rgba(255,255,255,0.1)', 120);
                    flashWarning.life = 50;
                    flashWarning.isWarning = true;
                    flashWarning.update = function() {
                        this.life--;
                        this.alpha = 1 - (this.life / 50);
                        if (this.life <= 0) enemyBullets.splice(enemyBullets.indexOf(this), 1);
                    }
                    setTimeout(() => {
                        if (!gameStarted || !boss.active) return;
                        createExplosion(flashWarning.x, flashWarning.y, '#ffff00', 40, 0.6);
                    }, 800);
                }
            }

            // â˜…è¿½åŠ : æœªå®Ÿè£…ã ã£ãŸéœŠå¤¢ã®ã‚¹ãƒšãƒ«ã‚«ãƒ¼ãƒ‰
            function fantasySealClump() {
                if (boss.phaseTimer % 40 === 0) {
                    const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                    for (let i = 0; i < 12; i++) {
                        const angle = angleToPlayer + (i - 5.5) * 0.1;
                        const speed = 2 + (i * 0.2);
                        createEnemyBullet(boss.x, boss.y, speed, angle, '#ff88ff', 8, 'amulet');
                    }
                }
            }

            function duplexDanmakuBarrier() {
                if (boss.phaseTimer % 10 === 0) {
                    const baseAngle1 = gameTime * 0.05;
                    const baseAngle2 = -gameTime * 0.05;
                    for (let i = 0; i < 2; i++) {
                        const angle1 = baseAngle1 + i * Math.PI;
                        const angle2 = baseAngle2 + i * Math.PI;
                        createEnemyBullet(boss.x, boss.y, 4, angle1, '#ffaaaa', 6);
                        createEnemyBullet(boss.x, boss.y, 4, angle2, '#aaaaff', 6);
                    }
                }
            }

            // --- Marisa Spell Cards ---
            function milkyWay() {
                if (boss.phaseTimer % 3 === 0) {
                    const x = Math.random() * canvas.width;
                    const speed = 3 + Math.random() * 3;
                    createEnemyBullet(x, 0, speed, Math.PI / 2, '#ffffaa', 8, 'star');
                }
            }
            function stardustReverie() {
                if (boss.phaseTimer % 1 === 0) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const bullet = createEnemyBullet(x, y, 0, 0, '#ddddff', 6, 'star');
                    bullet.alpha = 0;
                    bullet.life = 50;
                    bullet.update = function() {
                        this.life--;
                        if (this.life > 25) this.alpha = 1 - (this.life - 25) / 25;
                        else this.alpha = this.life / 25;
                        if (this.life === 25) {
                            this.angle = Math.random() * Math.PI * 2;
                            this.speed = 4;
                            this.dx = Math.cos(this.angle) * this.speed;
                            this.dy = Math.sin(this.angle) * this.speed;
                        }
                        if (this.life < 25) { this.x += this.dx; this.y += this.dy; }
                        if (this.life <= 0) enemyBullets.splice(enemyBullets.indexOf(this), 1);
                    }
                }
            }
            function nonDirectionalLaser() {
                if (boss.phaseTimer % 60 === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    for (let i = 0; i < 7; i++) {
                        try { if (sfx) sfx.laser.triggerAttackRelease('A3', '1s'); } catch(e) {}
                        createLaser(boss.x, boss.y, 12, angle + (i * Math.PI * 2 / 7), 100, 'rgb(255,255,100)');
                    }
                }
            }
            function masterSpark() {
                if (boss.phaseTimer > 60 && boss.phaseTimer % 180 === 1) {
                    try { if (sfx) sfx.laser.triggerAttackRelease('A2', '4s'); } catch(e) {}
                    const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    createLaser(boss.x, boss.y, 150, angle, 150, 'rgb(255,255,255)');
                }
            }
            function earthlightRay() {
                if (boss.phaseTimer % 30 === 0) {
                    try { if (sfx) sfx.laser.triggerAttackRelease('G3', '2s'); } catch(e) {}
                    const x = player.x + (Math.random() - 0.5) * 150;
                    createLaser(x, canvas.height, 20, -Math.PI / 2, 100, 'rgb(100,255,100)');
                }
            }
            function finalSpark() {
                 if (boss.phaseTimer > 60 && boss.phaseTimer % 240 === 1) {
                    try { if (sfx) sfx.laser.triggerAttackRelease('A1', '8s'); } catch(e) {}
                    const laser = createLaser(boss.x, boss.y, 250, Math.atan2(player.y - boss.y, player.x - boss.x), 200, 'rgb(255,100,255)');
                    laser.update = function() {
                        const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        this.angle += angleDiff * 0.015;
                    }
                }
            }

            // â˜…è¿½åŠ : æœªå®Ÿè£…ã ã£ãŸé­”ç†æ²™ã®ã‚¹ãƒšãƒ«ã‚«ãƒ¼ãƒ‰
            function meteonicShower() {
                if (boss.phaseTimer % 5 === 0) {
                    const x = Math.random() * canvas.width;
                    const angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                    createEnemyBullet(x, 0, 6, angle, '#ffffaa', 12, 'star');
                }
            }

            function asteroidBelt() {
                if (boss.phaseTimer % 60 === 0) {
                    const y = 100 + Math.random() * 200;
                    const speed = 2 + Math.random() * 2;
                    const dir = Math.random() < 0.5 ? 1 : -1;
                    for (let i = 0; i < 30; i++) {
                        const x = dir > 0 ? -i * 20 : canvas.width + i * 20;
                        const bullet = createEnemyBullet(x, y, speed * dir, 0, '#cccccc', 15);
                        bullet.dx = speed * dir;
                        bullet.dy = 0;
                    }
                }
            }

            function blazingStar() {
                if (boss.phaseTimer % 120 === 1) {
                    const bullet = createEnemyBullet(boss.x, boss.y, 0, 0, '#ff8800', 25, 'star');
                    bullet.speed = 1;
                    bullet.accel = 0.05;
                    bullet.update = function() {
                        const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        this.angle = targetAngle;
                        this.speed += this.accel;
                        this.dx = Math.cos(this.angle) * this.speed;
                        this.dy = Math.sin(this.angle) * this.speed;
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }

            // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
            function createEnemyBullet(x, y, speed, angle, color, radius, shape = 'circle') {
                const bullet = {
                    x, y, radius, color, shape,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    angle: shape === 'amulet' || shape === 'star' ? angle : 0,
                    grazed: false,
                };
                enemyBullets.push(bullet);
                return bullet;
            }

            function createLaser(x, y, width, angle, timer, color) {
                const laser = { x, y, width, angle, timer, color, alpha: 1 };
                lasers.push(laser);
                return laser;
            }

            function createExplosion(x, y, color, count, life = 1) {
                const c = color.match(/\w\w/g).map((c) => parseInt(c, 16));
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    particles.push({
                        x, y, radius: Math.random() * 3 + 1,
                        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                        r: c[0], g: c[1], b: c[2], alpha: 1 * life,
                    });
                }
            }

            function showOverlayMessage(html, duration) {
                messageOverlay.innerHTML = html;
                messageOverlay.style.display = 'flex';
                setTimeout(() => {
                    messageOverlay.style.display = 'none';
                }, duration * 1000 / 60);
            }

            function gameOver() {
                gameStarted = false;
                stopMusic();
                showOverlayMessage("GAME OVER", 300);
                setTimeout(() => {
                     startScreen.style.display = 'flex';
                }, 5000);
            }

            // --- Touch Handlers ---
            function handleTouchStart(e) {
                e.preventDefault();
                if (!gameStarted) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchX = (touch.clientX - rect.left) * scaleX;
                const touchY = (touch.clientY - rect.top) * scaleY;

                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                if (tapLength < 300 && tapLength > 0) {
                    fireBomb();
                    lastTap = 0;
                    isDragging = false;
                    return;
                }
                lastTap = currentTime;

                isDragging = true;
                touchStartX = touchX;
                touchStartY = touchY;
                playerStartX = player.x;
                playerStartY = player.y;
            }

            function handleTouchMove(e) {
                e.preventDefault();
                if (!isDragging || !gameStarted) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchX = (touch.clientX - rect.left) * scaleX;
                const touchY = (touch.clientY - rect.top) * scaleY;

                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;

                player.x = playerStartX + deltaX;
                player.y = playerStartY + deltaY;

                player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
                player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                if (!isDragging || !gameStarted) return;
                isDragging = false;
            }

            function updatePlayerOptions() {
                player.options = [];
                const numOptions = Math.min(4, Math.floor(player.power / 10));

                switch (numOptions) {
                    case 1:
                        player.options.push({ x: -30, y: 10 });
                        break;
                    case 2:
                        player.options.push({ x: -30, y: 10 });
                        player.options.push({ x: 30, y: 10 });
                        break;
                    case 3:
                        player.options.push({ x: -40, y: 10 }, { x: 40, y: 10 }, { x: 0, y: 30 });
                        break;
                    case 4:
                        player.options.push({ x: -40, y: 10 }, { x: 40, y: 10 }, { x: -25, y: 30 }, { x: 25, y: 30 });
                        break;
                }
            }

            function findClosestEnemy(x, y) {
                let closest = null;
                let closestDist = Infinity;

                const checkTarget = (target) => {
                    const dist = Math.hypot(x - target.x, y - target.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = target;
                    }
                };

                if (boss.active && boss.visible) {
                    checkTarget(boss);
                }
                // ãƒœã‚¹ãŒã„ãªã„å ´åˆã®ã¿ã‚¶ã‚³æ•µã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã™ã‚‹
                if (!closest) {
                    enemies.forEach(checkTarget);
                }

                return closest;
            }


            // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
            function gameLoop() {
                try {
                    if (!gameStarted) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // æ›´æ–°å‡¦ç†
                    updateStage();
                    updatePlayer();
                    updateBullets();
                    updatePowerUps();
                    updateBombItems();
                    updateEnemyBullets();
                    updateLasers();
                    updateEnemies();
                    updateBoss();
                    updateParticles();
                    checkCollisions();

                    // æç”»å‡¦ç†
                    drawEnemies();
                    drawBoss();
                    drawPlayer();
                    drawBullets();
                    drawPowerUps();
                    drawBombItems();
                    drawLasers();
                    drawEnemyBullets();
                    drawParticles();
                    drawPlayerBomb();
                    updateUI();

                    gameTime++;
                    requestAnimationFrame(gameLoop);
                } catch (e) {
                    console.error("An error occurred in the game loop:", e);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ«ãƒ¼ãƒ—ã‚’ç¶™ç¶šã—ã‚ˆã†ã¨è©¦ã¿ã‚‹
                    if (gameStarted) {
                        requestAnimationFrame(gameLoop);
                    }
                }
            }
        };
    </script>
</body>
</html>
